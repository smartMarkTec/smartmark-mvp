// server/routes/ai.js
'use strict';

const express = require('express');
const router = express.Router();

/* ------------------------ CORS ------------------------ */
const ALLOW_ORIGINS = new Set([
  'http://localhost:3000',
  'http://127.0.0.1:3000',
  'https://smartmark-mvp.vercel.app',
  process.env.FRONTEND_ORIGIN,
].filter(Boolean));

router.use((req, res, next) => {
  const origin = req.headers.origin;
  if (origin && ALLOW_ORIGINS.has(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }
  res.setHeader('Vary', 'Origin');
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With, X-FB-AD-ACCOUNT-ID');
  res.setHeader('Access-Control-Max-Age', '86400');
  if (req.method === 'OPTIONS') return res.sendStatus(204);
  next();
});

/* ------------------------------ Deps ------------------------------ */
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const sharp = require('sharp');
sharp.cache({ files: 0, items: 64, memory: 20 });
sharp.concurrency(1);

const { v4: uuidv4 } = require('uuid');
const FormData = require('form-data');
const { spawn } = require('child_process');
const seedrandom = require('seedrandom');
const { OpenAI } = require('openai');
const { getFbUserToken } = require('../tokenStore');

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const PEXELS_API_KEY = process.env.PEXELS_API_KEY;

/* --------------------------- Helpers --------------------------- */
function absolutePublicUrl(relativePath) {
  const base = process.env.PUBLIC_BASE_URL || process.env.RENDER_EXTERNAL_URL || 'https://smartmark-mvp.onrender.com';
  if (!relativePath) return '';
  if (/^https?:\/\//i.test(relativePath)) return relativePath;
  return `${base}${relativePath}`;
}
function getUserToken(req) {
  return req?.body?.userAccessToken || getFbUserToken() || null;
}
async function uploadVideoToAdAccount(adAccountId, userAccessToken, fileUrl, name = 'SmartMark Video', description = 'Generated by SmartMark') {
  const url = `https://graph.facebook.com/v23.0/act_${String(adAccountId).replace(/^act_/, '')}/advideos`;
  const form = new FormData();
  form.append('file_url', fileUrl);
  form.append('name', name);
  form.append('description', description);
  const resp = await axios.post(url, form, { headers: form.getHeaders(), params: { access_token: userAccessToken } });
  return resp.data;
}
function ensureGeneratedDir() {
  const outDir = process.env.RENDER ? '/tmp/generated' : path.join(__dirname, '../public/generated');
  try { fs.mkdirSync(outDir, { recursive: true }); } catch {}
  return outDir;
}
function maybeGC() { if (global.gc) try { global.gc(); } catch {} }

/* ---------- topic mapping (keeps visuals on-topic) ---------- */
const IMAGE_KEYWORD_MAP = [
  { match: ['protein powder','protein','supplement','muscle','fitness','gym'], keyword: 'gym workout' },
  { match: ['clothing','fashion','apparel','accessory'], keyword: 'fashion model' },
  { match: ['makeup','cosmetic','skincare'], keyword: 'makeup application' },
  { match: ['hair','shampoo'], keyword: 'hair care' },
  { match: ['food','pizza','burger','meal','snack'], keyword: 'delicious food' },
  { match: ['baby','kids','toys'], keyword: 'happy children' },
  { match: ['pet','dog','cat'], keyword: 'pet dog cat' },
  { match: ['electronics','phone','laptop','tech'], keyword: 'tech gadgets' },
  { match: ['home','kitchen','decor'], keyword: 'modern home' },
  { match: ['art','painting','craft'], keyword: 'painting art' },
  { match: ['coffee','cafe'], keyword: 'coffee shop' },
];
function getImageKeyword(industry = '', url = '') {
  const input = `${industry} ${url}`.toLowerCase();
  for (const row of IMAGE_KEYWORD_MAP) if (row.match.some(m => input.includes(m))) return row.keyword;
  return industry || 'ecommerce';
}
function deriveTopicKeywords(answers = {}, url = '', fallback = 'shopping') {
  const industry = answers.industry || answers.productType || '';
  const base = getImageKeyword(industry, url) || industry || fallback;
  const extra = String(answers.description || answers.product || answers.mainBenefit || '').toLowerCase();
  if (extra.includes('coffee')) return 'coffee shop';
  if (extra.includes('protein') || extra.includes('fitness') || extra.includes('gym')) return 'gym workout';
  if (extra.includes('makeup') || extra.includes('skincare') || extra.includes('cosmetic')) return 'makeup application';
  if (extra.includes('hair')) return 'hair care';
  if (extra.includes('pet') || extra.includes('dog') || extra.includes('cat')) return 'pet dog cat';
  if (extra.includes('electronics') || extra.includes('phone') || extra.includes('laptop')) return 'tech gadgets';
  return base;
}
function overlayTitleFromAnswers(answers = {}, topic = '') {
  const brand = (answers.businessName || '').trim().toUpperCase();
  if (brand) return brand.slice(0, 24);
  if (/fashion/i.test(topic)) return 'NEW ARRIVALS';
  return (topic || 'JUST DROPPED').toUpperCase().slice(0, 24);
}

/* ------------------------ Training context ------------------------ */
const DATA_DIR = path.join(__dirname, '../data');
const ALLOWED_EXT = new Set(['.txt', '.md', '.markdown', '.json']);
const MAX_FILE_MB = 1.5;
const MAX_TOTAL_CHARS = 45_000;
function loadTrainingContext() {
  if (!fs.existsSync(DATA_DIR)) return '';
  const files = fs.readdirSync(DATA_DIR)
    .map(f => path.join(__dirname, '../data', f))
    .filter(full => {
      const ext = path.extname(full).toLowerCase();
      try {
        const st = fs.statSync(full);
        return st.isFile() && ALLOWED_EXT.has(ext) && st.size <= MAX_FILE_MB * 1024 * 1024;
      } catch { return false; }
    });
  let ctx = '';
  for (const f of files) {
    try {
      const ext = path.extname(f).toLowerCase();
      let text = fs.readFileSync(f, 'utf8');
      if (ext === '.json') { try { text = JSON.stringify(JSON.parse(text)); } catch {} }
      if (!text.trim()) continue;
      const block = `\n\n### SOURCE: ${path.basename(f)}\n${text}\n`;
      if (ctx.length + block.length <= MAX_TOTAL_CHARS) ctx += block;
    } catch {}
  }
  return ctx.trim();
}
let customContext = loadTrainingContext();

/* ---------------------------- Scrape ---------------------------- */
router.get('/test', (_req, res) => res.json({ msg: 'AI route is working!' }));

async function getWebsiteText(url) {
  try {
    const clean = String(url || '').trim();
    if (!clean || !/^https?:\/\//i.test(clean)) throw new Error('Invalid URL');
    const { data, headers } = await axios.get(clean, { timeout: 7000, maxRedirects: 3, validateStatus: s => s < 400 });
    if (!headers['content-type']?.includes('text/html')) throw new Error('Not HTML');
    const body = String(data)
      .replace(/<script[\s\S]*?<\/script>/gi, '')
      .replace(/<style[\s\S]*?<\/style>/gi, '')
      .replace(/<[^>]+>/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
    if (body.length < 200 || /cloudflare|access denied|429/i.test(body)) throw new Error('blocked/short');
    return body.slice(0, 3500);
  } catch {
    return '';
  }
}

/* --------------------------- Ad Copy --------------------------- */
router.post('/generate-ad-copy', async (req, res) => {
  const { description = '', businessName = '', url = '' } = req.body;
  if (!description && !businessName && !url) return res.status(400).json({ error: 'Please provide at least a description.' });

  let prompt =
`You are an expert direct-response ad copywriter.
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}Write only the exact words for a spoken video ad script (about 46–72 words ≈ 15–17 seconds).
- Keep it neutral and accurate; avoid assumptions about shipping, returns, guarantees, or inventory.
- Hook → value → simple CTA (from common CTAs like “Shop now”, “Buy now”, “Learn more”, “Visit us”, “Check us out”, “Take a look”, “Get started”).
- Do NOT mention a website or domain.`;
  if (description) prompt += `\nBusiness Description: ${description}`;
  if (businessName) prompt += `\nBusiness Name: ${businessName}`;
  if (url) prompt += `\nWebsite (for context only): ${url}`;
  prompt += `\nOutput ONLY the script text.`;

  try {
    const r = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 220,
      temperature: 0.35
    });
    res.json({ adCopy: r.choices?.[0]?.message?.content?.trim() || '' });
  } catch {
    res.status(500).json({ error: 'Failed to generate ad copy' });
  }
});

/* ------------------- Headlines/body for images ------------------- */
router.post('/generate-campaign-assets', async (req, res) => {
  try {
    const { answers = {}, url = '' } = req.body;

    const brandFromUrl = (u = '') => {
      try {
        const h = new URL(u).hostname.replace(/^www\./, '');
        const base = h.split('.')[0] || 'Your Brand';
        return base.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
      } catch { return 'Your Brand'; }
    };
    const brand = (answers.businessName && String(answers.businessName).trim()) || brandFromUrl(url);
    const industry = (answers.industry && String(answers.industry).trim()) || '';
    const mainBenefit = (answers.mainBenefit && String(answers.mainBenefit).trim()) || '';
    const offer = (answers.offer && String(answers.offer).trim()) || '';

    let websiteText = '';
    try { if (url && /^https?:\/\//i.test(url)) websiteText = await getWebsiteText(url); } catch {}

    const prompt = `
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}You are a senior direct-response copywriter.
Write JSON ONLY:

{
  "headline": "max 55 characters, plain and neutral (no assumptions)",
  "body": "18-30 words, friendly and value-focused, neutral claims only, no emojis/hashtags",
  "image_overlay_text": "4 words max, simple CTA in ALL CAPS"
}

Rules:
- Prefer simple phrasing; avoid jargon like "global finds" or promises like "fast shipping".
- Never include a website or domain.
Context:
Brand: ${brand}
Industry: ${industry || '[general ecommerce]'}
Main benefit: ${mainBenefit || '[unspecified]'}
Offer: ${offer || '[none]'}
Website text (may be empty): """${(websiteText || '').slice(0, 1200)}"""`.trim();

    let headline = '', body = '', overlay = '';
    try {
      const r = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 220,
        temperature: 0.35
      });
      const raw = r.choices?.[0]?.message?.content?.trim() || '{}';
      const jsonStr = (raw.match(/\{[\s\S]*\}/) || [raw])[0];
      const parsed = JSON.parse(jsonStr);

      const clean = (s, max = 200) => String(s || '').replace(/\s+/g, ' ').trim().slice(0, max);
      headline = clean(parsed.headline, 55);
      body = clean(parsed.body, 220);
      overlay = clean(parsed.image_overlay_text, 28);
    } catch {
      headline = `${brand}: New Styles`;
      body = `Explore easy, everyday pieces with a focus on feel and fit. Browse the latest looks and find what works for you.`;
      overlay = 'LEARN MORE';
    }

    headline = headline.replace(/["<>]/g, '').slice(0, 55);
    body = body.replace(/["<>]/g, '').replace(/\s+/g, ' ').trim();

    // Force CTA to allowed set (no “Browse styles”, “New arrivals”, etc.)
    overlay = pickFromAllowedCTAs(answers).toUpperCase();

    return res.json({ headline, body, image_overlay_text: overlay });
  } catch {
    return res.json({
      headline: 'New Styles Just In',
      body: 'Explore everyday pieces designed for comfort and ease. See what’s new and find your next go-to.',
      image_overlay_text: 'LEARN MORE'
    });
  }
});

/* ------------------------------ Audience ------------------------------ */
const DEFAULT_AUDIENCE = {
  brandName: '', demographic: '', ageRange: '18-65',
  location: 'US', interests: 'Business, Restaurants', fbInterestIds: [], summary: ''
};

async function extractKeywords(text) {
  const prompt = `
Extract up to 6 compact keywords (one or two words each) from this text that would be useful Facebook interest seeds.
Return them as a comma-separated list ONLY. No extra words.

TEXT:
"""${(text || '').slice(0, 3000)}"""`.trim();

  try {
    const r = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 40,
      temperature: 0.2
    });
    return (r.choices?.[0]?.message?.content || '')
      .replace(/[\n.]/g, '')
      .toLowerCase()
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);
  } catch { return []; }
}

async function getFbInterestIds(keywords, fbToken) {
  const out = [];
  for (const k of keywords) {
    try {
      const r = await axios.get('https://graph.facebook.com/v18.0/search', {
        params: { type: 'adinterest', q: k, access_token: fbToken, limit: 1 }
      });
      if (r.data?.data?.[0]?.id) out.push({ id: r.data.data[0].id, name: r.data.data[0].name });
    } catch {}
  }
  return out;
}

router.post('/detect-audience', async (req, res) => {
  const { url } = req.body;
  const fbToken = req.body.fbToken || getFbUserToken();
  if (!url) return res.status(400).json({ error: 'Missing URL' });

  const websiteText = await getWebsiteText(url);
  const safe = websiteText.length > 100 ? websiteText : '[WEBSITE TEXT UNAVAILABLE]';

  const prompt = `
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}
Answer ONLY this JSON:
{"brandName":"","demographic":"","ageRange":"","location":"","interests":"","summary":""}
Website homepage text:
"""${safe}"""`.trim();

  try {
    const r = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 220,
      temperature: 0.3
    });

    const txt = r.choices?.[0]?.message?.content?.trim() || '{}';
    let aud;
    try {
      const m = txt.match(/\{[\s\S]*\}/);
      aud = JSON.parse(m ? m[0] : txt);
      aud = {
        brandName: aud.brandName || '',
        demographic: aud.demographic || '',
        ageRange: /^\d{2}-\d{2}$/.test(aud.ageRange || '') ? aud.ageRange : '18-65',
        location: (aud.location || 'US').toString().trim().toUpperCase() || 'US',
        interests: aud.interests || 'Business, Restaurants',
        summary: aud.summary || ''
      };
    } catch {
      return res.json({ audience: DEFAULT_AUDIENCE });
    }

    if (fbToken) {
      const kws = await extractKeywords(websiteText);
      const fb = await getFbInterestIds(kws, fbToken);
      aud.fbInterestIds = fb.map(i => i.id);
      aud.fbInterestNames = fb.map(i => i.name);
    } else {
      aud.fbInterestIds = [];
      aud.fbInterestNames = [];
    }
    res.json({ audience: aud });
  } catch {
    res.json({ audience: DEFAULT_AUDIENCE });
  }
});

/* ---------------------- Image overlays ---------------------- */
const PEXELS_IMG_BASE = 'https://api.pexels.com/v1/search';
function escSVG(s){return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;')}
function estWidth(text, fs){return (String(text||'').length||1)*fs*0.56}
function fitFont(text, maxW, startFs, minFs=30){let fs=startFs;while(fs>minFs&&estWidth(text,fs)>maxW)fs-=2;return fs}
function splitTwoLines(text,maxW,startFs){
  const words=String(text||'').split(/\s+/).filter(Boolean);
  if(words.length<=2)return{lines:[text],fs:fitFont(text,maxW,startFs)};
  for(let cut=Math.ceil(words.length/2);cut<words.length-1;cut++){
    const a=words.slice(0,cut).join(' '),b=words.slice(cut).join(' ');
    let fs=startFs;fs=Math.min(fitFont(a,maxW,fs),fitFont(b,maxW,fs));
    if(estWidth(a,fs)<=maxW && estWidth(b,fs)<=maxW) return {lines:[a,b],fs};
  }
  return {lines:[text],fs:fitFont(text,maxW,startFs)};
}
const BANNED_TERMS = /\b(unisex|global|vibes?|forward|finds?|chic|bespoke|avant|couture)\b/i;
function cleanHeadline(h){
  h=String(h||'').replace(/[^a-z0-9 &\-]/gi,' ').replace(/\s+/g,' ').trim();
  if(!h || BANNED_TERMS.test(h)) return '';
  const words=h.split(' '); if(words.length<2||words.length>4) return '';
  return h.toUpperCase();
}

/* Allowed CTA list (used everywhere) */
const ALLOWED_CTAS = [
  'SHOP NOW!', 'BUY NOW!', 'CHECK US OUT!', 'VISIT US!',
  'TAKE A LOOK!', 'LEARN MORE!', 'GET STARTED!'
];
function pickFromAllowedCTAs(answers = {}, seed = '') {
  const t = String(answers?.cta || '').trim();
  if (t) {
    const norm = t.toUpperCase().replace(/['’]/g,'').replace(/[^A-Z0-9 !?]/g,'').replace(/\s+/g,' ').trim();
    const withBang = /!$/.test(norm) ? norm : `${norm}!`;
    if (ALLOWED_CTAS.includes(withBang)) return withBang;
  }
  let h = 0; for (const c of String(seed || Date.now())) h = (h*31 + c.charCodeAt(0))>>>0;
  return ALLOWED_CTAS[h % ALLOWED_CTAS.length];
}

/* CTA text (image/video safe) */
function cleanCTA(c){
  const norm = String(c||'').toUpperCase().replace(/['’]/g,'').replace(/[^A-Z0-9 !?]/g,'').replace(/\s+/g,' ').trim();
  const withBang = /!$/.test(norm) ? norm : (norm ? `${norm}!` : '');
  return ALLOWED_CTAS.includes(withBang) ? withBang : 'LEARN MORE!';
}

/* ---- 4 overlay templates: Left / Top / Center / Left gradient ---- */
/* (Bottom centered template removed per request) */
function svgOverlay({ W, H, headline, cta, tpl=2 }) {
  const LIGHT = '#f2f5f6';
  const MAX_W = W - 120;
  const EST = estWidth;

  const pill = (x, y, text, fs=28, align='center') => {
    fs = Math.max(22, Math.min(fs, 34));
    const w = Math.min(MAX_W, EST(text, fs) + 44), h = 46;
    const x0 = align==='left' ? x - w/2 : (x - w/2);
    return `
      <g transform="translate(${x0}, ${y - Math.floor(h*0.6)})">
        <rect x="0" y="-14" width="${w}" height="${h}" rx="14" fill="#0b0d10d0"/>
        <text x="${w/2}" y="12" text-anchor="middle" font-family="Times New Roman, Times, serif" font-size="${fs}" font-weight="800" fill="#ffffff">${escSVG(text)}</text>
      </g>`;
  };

  // Top band
  if (tpl === 2) {
    let fs = fitFont(headline, MAX_W-80, 56);
    const yTitle = 92;
    const yCTA = yTitle + 60;
    return `
      <defs><linearGradient id="g2" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#000c"/><stop offset="100%" stop-color="#0000"/></linearGradient></defs>
      <rect x="0" y="0" width="${W}" height="170" rx="18" fill="url(#g2)"/>
      <text x="${W/2}" y="${yTitle}" text-anchor="middle" font-family="Times New Roman, Times, serif" font-size="${fs}" font-weight="700" fill="${LIGHT}" letter-spacing="2">${escSVG(headline)}</text>
      ${pill(W/2, yCTA, cta, 28, 'center')}
    `;
  }

  // Center box
  if (tpl === 3) {
    const boxW = 860;
    const fit = splitTwoLines(headline, boxW-100, 56);
    const lineCount = fit.lines.length;
    const boxPad = 28;
    const gap = 18;
    const boxH = Math.round(boxPad*2 + fit.fs*(lineCount) + 54 + gap);
    const yBox = Math.round((H - boxH)/2);
    const yTitle = yBox + boxPad + fit.fs - 6;
    const yCTA = yBox + boxH - boxPad - 12;

    return `
      <rect x="${(W-boxW)/2}" y="${yBox}" width="${boxW}" height="${boxH}" rx="22" fill="#00000030"/>
      <text x="${W/2}" y="${yTitle}" text-anchor="middle" font-family="Times New Roman, Times, serif" font-size="${fit.fs}" font-weight="700" fill="#f2f5f6" letter-spacing="2">
        <tspan x="${W/2}" dy="0">${escSVG(fit.lines[0])}</tspan>
        ${fit.lines[1]?`<tspan x="${W/2}" dy="${fit.fs*1.05}">${escSVG(fit.lines[1])}</tspan>`:''}
      </text>
      ${pill(W/2, yCTA, cta, 28, 'center')}
    `;
  }

  // Left gradient
  const padX = 64, padY = 110, panelW = 520;
  const fit = splitTwoLines(headline, panelW-2*padX, 54);
  const yBase = padY;
  const yCTA  = yBase + fit.fs*1.05*(fit.lines.length) + 48;
  return `
    <defs><linearGradient id="gL" x1="0" y1="0" x2="1" y2="0"><stop offset="0%" stop-color="#000a"/><stop offset="100%" stop-color="#0000"/></linearGradient></defs>
    <rect x="0" y="0" width="${panelW}" height="${H}" fill="url(#gL)"/>
    <text x="${padX}" y="${yBase}" text-anchor="start" font-family="Times New Roman, Times, serif" font-size="${fit.fs}" font-weight="700" fill="#f2f5f6" letter-spacing="2">
      <tspan x="${padX}" dy="0">${escSVG(fit.lines[0])}</tspan>
      ${fit.lines[1]?`<tspan x="${padX}" dy="${fit.fs*1.05}">${escSVG(fit.lines[1])}</tspan>`:''}
    </text>
    ${pill(padX + Math.max(90, (panelW-2*padX)/2), yCTA, cta, 26, 'center')}
  `;
}

async function buildOverlayImage({ imageUrl, headlineHint = '', ctaHint = '', seed = '' }) {
  const W = 1200, H = 627;
  const imgRes = await axios.get(imageUrl, { responseType: 'arraybuffer' });
  const base = sharp(imgRes.data).resize(W, H, { fit: 'cover' });

  let headline = cleanHeadline(headlineHint) || 'NEW ARRIVALS';
  let cta = cleanCTA(ctaHint) || 'LEARN MORE!';

  let h = 0; for (const c of String(seed || Date.now())) h = (h*31 + c.charCodeAt(0))>>>0;
  // Only use Top (2), Center (3), Left (4) — bottom template removed
  const tpl = [2,3,4][h % 3];

  const overlaySVG = Buffer.from(
    `<svg width="${W}" height="${H}" xmlns="http://www.w3.org/2000/svg">${svgOverlay({ W, H, headline, cta, tpl })}</svg>`
  );

  const outDir = ensureGeneratedDir();
  const file = `${uuidv4()}.jpg`;
  await base
    .composite([{ input: overlaySVG, top: 0, left: 0 }])
    .jpeg({ quality: 92 })
    .toFile(path.join(outDir, file));

  maybeGC();
  return { publicUrl: `/generated/${file}`, absoluteUrl: absolutePublicUrl(`/generated/${file}`) };
}

/* ------------------------------ Music ------------------------------ */
function findMusicDir() {
  const candidates = [
    path.join(__dirname, '..', 'Music', 'music'),
    path.join(__dirname, '..', 'music', 'music'),
    path.join(__dirname, '..', 'Music'),
    path.join(__dirname, '..', 'music')
  ];
  for (const p of candidates) { try { if (fs.existsSync(p) && fs.statSync(p).isDirectory()) return p; } catch {} }
  return null;
}
function pickMusicFile(keywords = []) {
  const base = findMusicDir();
  if (!base) return null;
  const files = fs.readdirSync(base).filter(f => /\.mp3$/i.test(f));
  if (!files.length) return null;
  const lower = files.map(f => f.toLowerCase());
  for (const kw of keywords.map(x => String(x).toLowerCase())) {
    let i = lower.findIndex(f => f === `${kw}.mp3`); if (i !== -1) return path.join(base, files[i]);
    i = lower.findIndex(f => f.includes(kw)); if (i !== -1) return path.join(base, files[i]);
  }
  return path.join(base, files[0]);
}

/* ------------------------------- Utils ------------------------------- */
function withTimeout(p, ms, msg='Timeout') { return Promise.race([p, new Promise((_,rej)=>setTimeout(()=>rej(new Error(msg)), ms))]); }

async function downloadFileWithTimeout(url, dest, timeoutMs=26000, maxSizeMB=6) {
  return new Promise((resolve, reject) => {
    if (!url || !/^https?:\/\//i.test(String(url))) return reject(new Error('Invalid clip URL'));
    const writer = fs.createWriteStream(dest);
    let timedOut = false;
    const timeout = setTimeout(()=>{timedOut=true;writer.destroy();try{fs.unlinkSync(dest);}catch{};reject(new Error('Download timed out'));}, timeoutMs);
    axios({ url, method:'GET', responseType:'stream' })
      .then(resp => {
        let bytes=0;
        resp.data.on('data', ch => { bytes+=ch.length; if (bytes > maxSizeMB*1024*1024 && !timedOut) { timedOut=true; writer.destroy(); try{fs.unlinkSync(dest);}catch{}; clearTimeout(timeout); reject(new Error('File too large')); }});
        resp.data.on('error', err => { clearTimeout(timeout); if (!timedOut) reject(err); });
        resp.data.pipe(writer);
        writer.on('finish', ()=>{clearTimeout(timeout); if (!timedOut) resolve(dest);});
        writer.on('error', err=>{clearTimeout(timeout); try{fs.unlinkSync(dest);}catch{}; if (!timedOut) reject(err);});
      })
      .catch(err=>{clearTimeout(timeout); try{fs.unlinkSync(dest);}catch{}; reject(err);});
  });
}

function getDeterministicShuffle(arr, seed) {
  const rng = seedrandom(String(seed || Date.now()));
  const a = [...arr];
  for (let i=a.length-1;i>0;i--){const j=Math.floor(rng()*(i+1));[a[i],a[j]]=[a[j],a[i]];}
  return a;
}

function safeFFText(t){
  return String(t||'')
    .replace(/['’]/g,'')
    .replace(/[\n\r]/g,' ')
    .replace(/[:]/g,' ')
    .replace(/[\\"]/g,'')
    .replace(/(?:https?:\/\/)?(?:www\.)?[a-z0-9\-]+\.[a-z]{2,}(?:\/\S*)?/gi,'')
    .replace(/\b(dot|com|net|org|io|co)\b/gi,'')
    .replace(/[^A-Za-z0-9 !?\-]/g,' ')
    .replace(/\s+/g,' ')
    .trim()
    .toUpperCase()
    .slice(0, 40);
}

/* ---- CTA pool (strict common list, rotates on regenerate) ---- */
function chooseCTA(answers={}, seed='') {
  return pickFromAllowedCTAs(answers, seed);
}

/* -------------------------- Spawned processes -------------------------- */
function runSpawn(cmd, args, opts = {}) {
  return new Promise((resolve, reject) => {
    const child = spawn(cmd, args, {
      stdio: ['ignore', 'ignore', 'inherit'],
      ...opts,
    });
    let killed = false;
    const killTimer = opts.killAfter ? setTimeout(() => {
      killed = true;
      try { child.kill('SIGKILL'); } catch {}
      reject(new Error(opts.killMsg || 'process timeout'));
    }, opts.killAfter) : null;

    child.on('error', err => { if (killTimer) clearTimeout(killTimer); reject(err); });
    child.on('close', code => {
      if (killTimer) clearTimeout(killTimer);
      if (killed) return;
      code === 0 ? resolve() : reject(new Error(`${cmd} exited with code ${code}`));
    });
  });
}
async function probeDuration(file, timeoutMs=8000) {
  return new Promise((resolve) => {
    const child = spawn('ffprobe', ['-v', 'error', '-show_entries', 'format=duration', '-of', 'default=nokey=1:noprint_wrappers=1', file], { stdio: ['ignore', 'pipe', 'ignore'] });
    let out = '';
    const timer = setTimeout(()=>{ try { child.kill('SIGKILL'); } catch {}; resolve(0); }, timeoutMs);
    child.stdout.on('data', d => { if (out.length < 64) out += d.toString('utf8'); });
    child.on('close', () => { clearTimeout(timer); const s = parseFloat(out.trim()); resolve(isNaN(s)?0:s); });
    child.on('error', () => { clearTimeout(timer); resolve(0); });
  });
}

/* ------------------------------- VIDEO ------------------------------- */
function pickSerifFontFile() {
  const candidates = [
    '/usr/share/fonts/truetype/msttcorefonts/Times_New_Roman.ttf',
    '/usr/share/fonts/truetype/msttcorefonts/Times_New_Roman_Bold.ttf',
    '/usr/share/fonts/truetype/msttcorefonts/times.ttf',
    '/usr/share/fonts/truetype/freefont/FreeSerif.ttf',
    '/usr/share/fonts/truetype/noto/NotoSerif-Regular.ttf',
    '/usr/share/fonts/truetype/dejavu/DejaVuSerif-Bold.ttf',
    '/usr/share/fonts/truetype/dejavu/DejaVuSerif.ttf'
  ];
  for (const p of candidates) { try { if (fs.existsSync(p)) return p; } catch {} }
  return null;
}

/**
 * Single design (unchanged look):
 * - Square 640x640 with blurred fill + centered fit.
 * - Side curtains fade after clip #1.
 * - Top intro band shows Brand only (with "!"), Times New Roman if available.
 * - Big centered outro CTA.
 * - Voiceover ≥ 14s, visuals ≥ VO + 2s (total ≥ 16s). VO ends ~2s before end.
 */
router.post('/generate-video-ad', async (req, res) => {
  res.setHeader('Content-Type', 'application/json');
  try {
    const { url = '', answers = {}, regenerateToken = '' } = req.body;

    const token = getUserToken(req);
    const fbAdAccountId =
      req.body.fbAdAccountId ||
      req.query.adAccountId ||
      req.headers['x-fb-ad-account-id'] ||
      null;

    const VIDEO = { W: 640, H: 640, FPS: 24 };
    const TO = { PEXELS: 16000, DL: 28000, OVERMUX: 120000 };

    const topic = deriveTopicKeywords(answers, url, 'shopping');
    const brandBase = (answers?.businessName && String(answers.businessName).trim()) || overlayTitleFromAnswers(answers, topic);
    let brandForVideo = (brandBase || 'Your Brand').toUpperCase().replace(/[^A-Z0-9 \-]/g,'').trim();
    if (!/!$/.test(brandForVideo)) brandForVideo += '!';
    const ctaText = chooseCTA(answers, regenerateToken || answers?.businessName || topic);

    /* ---- Stock clips ---- */
    let candidates = [];
    try {
      const r = await axios.get('https://api.pexels.com/videos/search', {
        headers: { Authorization: PEXELS_API_KEY },
        params: { query: topic, per_page: 36, cb: Date.now() + (regenerateToken || '') },
        timeout: TO.PEXELS
      });
      const videos = r.data?.videos || [];
      for (const v of videos) {
        if ((v.duration || 0) < 7) continue;
        const files = (v.video_files || [])
          .filter(f => f?.link && /\.mp4(\?|$)/i.test(f.link))
          .sort((a, b) => (a.width || 9999) - (b.width || 9999));
        if (files[0]?.link) candidates.push({ link: files[0].link, duration: v.duration || 8 });
      }
    } catch {
      return res.status(500).json({ error: 'Stock video fetch failed' });
    }
    if (candidates.length < 3) return res.status(404).json({ error: 'Not enough stock clips found' });
    const chosen = getDeterministicShuffle(candidates, regenerateToken || answers?.businessName || topic || Date.now()).slice(0, 3);

    const tmp = path.join(__dirname, '../tmp');
    try { fs.mkdirSync(tmp, { recursive: true }); } catch {}
    const inputs = [];
    for (const c of chosen) {
      const out = path.join(tmp, `${uuidv4()}.mp4`);
      await downloadFileWithTimeout(c.link, out, TO.DL, 6);
      inputs.push(out);
    }

    /* ---- Script generation (neutral) with length guard ---- */
    const buildPrompt = (targetWordsLow, targetWordsHigh) => {
      const base =
`Write a simple, neutral spoken ad script about ${topic}.
- About ${targetWordsLow}-${targetWordsHigh} words (~${Math.round(targetWordsHigh/4)}s).
- Avoid assumptions (no promises about shipping, returns, guarantees, or inventory).
- No website or domain. End with this exact CTA: "${ctaText}".
- Structure: brief hook → value/what to expect → CTA.`;
      let p = base;
      if (answers?.industry) p += `\nCategory (for context): ${answers.industry}`;
      if (answers?.businessName) p += `\nBrand (name only): ${answers.businessName}`;
      if (url) p += `\nWebsite (for context only): ${url}`;
      p += `\nOutput ONLY the script text.`;
      return p;
    };

    async function makeTTS(scriptText) {
      const file = path.join(tmp, `${uuidv4()}.mp3`);
      const ttsRes = await openai.audio.speech.create({ model: 'tts-1', voice: 'alloy', input: scriptText, timeout: 18000 });
      fs.writeFileSync(file, Buffer.from(await ttsRes.arrayBuffer()));
      return file;
    }

    let script = '';
    let ttsPath = '';
    let voDur = 0;

    // Retry up to 3x targeting longer scripts until VO >= 14s
    const targets = [
      [46, 58],
      [58, 72],
      [70, 84]
    ];
    for (let attempt = 0; attempt < targets.length; attempt++) {
      const [low, high] = targets[attempt];
      try {
        const r = await openai.chat.completions.create({
          model: 'gpt-4o',
          messages: [{ role: 'user', content: buildPrompt(low, high) }],
          max_tokens: 280,
          temperature: 0.35,
          timeout: 14000
        });
        script = (r.choices?.[0]?.message?.content?.trim() || '')
          .replace(/\s+/g, ' ')
          .replace(/(?:https?:\/\/)?(?:www\.)?[a-z0-9\-]+\.[a-z]{2,}(?:\/\S*)?/gi, '')
          .replace(/\b(dot|com|net|org|io|co)\b/gi, '')
          .trim();
      } catch {
        script = script || `Find pieces that fit your day. Explore styles, materials, and details you can feel good about. ${ctaText}`;
      }

      try {
        if (ttsPath) { try { fs.unlinkSync(ttsPath); } catch {} }
        ttsPath = await makeTTS(script);
      } catch {
        return res.status(500).json({ error: 'TTS generation failed' });
      }

      voDur = await probeDuration(ttsPath);
      if (voDur >= 14.0) break;

      // On last pass, extend with a neutral closer
      if (attempt === targets.length - 1) {
        script += ` Take a look and see what feels right for you. ${ctaText}`;
        try {
          if (ttsPath) { try { fs.unlinkSync(ttsPath); } catch {} }
          ttsPath = await makeTTS(script);
        } catch {}
        voDur = await probeDuration(ttsPath);
      }
    }
    if (voDur <= 0) voDur = 14.0;

    /* ---- Durations (visuals >= VO + 2s, and >= 16s total) ---- */
    const finalDur = Math.max(16.0, Math.min(voDur + 2.2, 30.0));

    const seg1 = Math.min(6.2, Math.max(4.8, finalDur * 0.36));
    const seg2 = Math.max(4.2, (finalDur - seg1) / 2);
    const seg3 = Math.max(4.0, finalDur - seg1 - seg2);
    const segs = [seg1, seg2, seg3];

    /* ---- Overlays (Times New Roman if available) ---- */
    const serifFile = pickSerifFontFile();
    const fontParam = serifFile ? `fontfile='${serifFile}':` : `font='Times New Roman':`;

    const brandLine = safeFFText(brandForVideo);
    const ctaTxt    = safeFFText(ctaText);

    const introStart = 0.25;
    const introEnd   = Math.min(segs[0] - 0.25, 3.2);
    const outroStart = Math.max(0.0, finalDur - 2.3);
    const outroEnd   = finalDur;

    const TOP_H   = Math.round(640 * 0.18);
    const CUR_W   = Math.round(640 * 0.13);

    const txtCommon = `fontcolor=white@0.99:borderw=2:bordercolor=black@0.88:shadowx=1:shadowy=1:shadowcolor=black@0.75`;

    const yBrand = Math.round(TOP_H * 0.56);

    const introOverlay =
      `drawtext=${fontParam}text='${brandLine}':${txtCommon}:fontsize=30:x=(w-tw)/2:y=${yBrand}:enable='between(t,${(introStart+0.10).toFixed(2)},${introEnd.toFixed(2)})'`;

    const outroOverlay =
      `drawtext=${fontParam}text='${ctaTxt}':${txtCommon}:box=1:boxcolor=0x0b0d10@0.82:boxborderw=20:fontsize=44:x=(w-tw)/2:y=(h/2-16):enable='between(t,${outroStart.toFixed(2)},${outroEnd.toFixed(2)})'`;

    /* ---- Build visuals (force consistent fps/pixfmt to prevent sputter) ---- */
    const baseLook = `setsar=1,fps=${VIDEO.FPS},format=yuv420p,settb=AVTB`;
    const vidParts = [];
    for (let i = 0; i < inputs.length; i++) {
      const dur = segs[i];
      vidParts.push(
        `[${i}:v]split=2[v${i}a][v${i}b];` +
        `[v${i}a]scale=640:640:force_original_aspect_ratio=increase,boxblur=luma_radius=18:luma_power=1:chroma_radius=18:chroma_power=1,crop=640:640[bg${i}];` +
        `[v${i}b]scale='if(gte(iw/ih,1),640,-2)':'if(gte(iw/ih,1),-2,640)',setsar=1[fit${i}];` +
        `[bg${i}][fit${i}]overlay=x=(main_w-overlay_w)/2:y=(main_h-overlay_h)/2,${baseLook},trim=0:${dur.toFixed(2)},setpts=PTS-STARTPTS[s${i}]`
      );
    }
    const concat = `[s0][s1][s2]concat=n=3:v=1:a=0[vseq]`;

    const curtainFadeStart = Math.max(0.2, segs[0] - 0.55).toFixed(2);
    const curtains =
      `color=c=black@0.85:s=${CUR_W}x640:d=${finalDur.toFixed(2)},format=rgba,fade=t=out:st=${curtainFadeStart}:d=0.55:alpha=1[left];` +
      `color=c=black@0.85:s=${CUR_W}x640:d=${finalDur.toFixed(2)},format=rgba,fade=t=out:st=${curtainFadeStart}:d=0.55:alpha=1[right];` +
      `[vseq][left]overlay=shortest=1:x=0:y=0[b1];[b1][right]overlay=shortest=1:x=main_w-overlay_w:y=0[b2]`;

    const bandFadeStart = (segs[0]-0.60).toFixed(2);
    const band =
      `color=c=black@0.52:s=640x${TOP_H}:d=${finalDur.toFixed(2)},format=rgba,fade=t=out:st=${bandFadeStart}:d=0.6:alpha=1[top];` +
      `[b2][top]overlay=shortest=1:x=0:y=0[b3]`;

    let filterVisual = curtains + ';' + band + `;[b3]${introOverlay},${outroOverlay}[v]`;
    let filterComplex = vidParts.join(';') + ';' + concat + ';' + filterVisual;

    // Audio: voice + optional bg music (pad to finalDur so lengths match)
    const ttsIdx = inputs.length;
    const keys = [];
    if (answers?.industry) keys.push(answers.industry);
    if (answers?.businessName) keys.push(answers.businessName);
    let bgMusicPath = null;
    try { bgMusicPath = pickMusicFile(keys); } catch {}
    const musicIdx = ttsIdx + 1;

    if (bgMusicPath) {
      filterComplex += `;[${ttsIdx}:a]aresample=44100,pan=stereo|c0=c0|c1=c0,atrim=0:${finalDur.toFixed(2)},apad=pad_dur=${finalDur.toFixed(2)}[voice];` +
                       `[${musicIdx}:a]aresample=44100,volume=0.18,atrim=0:${finalDur.toFixed(2)},apad=pad_dur=${finalDur.toFixed(2)}[bg];` +
                       `[voice][bg]amix=inputs=2:duration=longest:normalize=1[mix]`;
    } else {
      filterComplex += `;[${ttsIdx}:a]aresample=44100,pan=stereo|c0=c0|c1=c0,atrim=0:${finalDur.toFixed(2)},apad=pad_dur=${finalDur.toFixed(2)}[mix]`;
    }

    const outDir = ensureGeneratedDir();
    const id = uuidv4();
    const outPath = path.join(outDir, `${id}.mp4`);

    const args = [];
    for (const f of inputs) { args.push('-i', f); }
    args.push('-i', ttsPath);
    if (bgMusicPath) args.push('-i', bgMusicPath);
    args.push(
      '-filter_complex', filterComplex,
      '-map', '[v]', '-map', '[mix]',
      '-t', finalDur.toFixed(2),
      '-r', String(VIDEO.FPS),
      '-vsync', 'vfr',
      '-c:v', 'libx264', '-preset', 'ultrafast', '-crf', '28', '-pix_fmt', 'yuv420p',
      '-c:a', 'aac', '-b:a', '128k', '-ar', '44100',
      '-movflags', '+faststart',
      '-loglevel', 'error',
      outPath
    );

    await runSpawn('ffmpeg', args, { killAfter: TO.OVERMUX, killMsg: 'overlay+mux timeout' });

    // cleanup
    for (const f of inputs) { try { fs.unlinkSync(f); } catch {} }
    try { fs.unlinkSync(ttsPath); } catch {}
    maybeGC();

    const publicVideoUrl = `/generated/${id}.mp4`;
    const absoluteUrl = absolutePublicUrl(publicVideoUrl);

    let fbVideoId = null;
    try {
      if (fbAdAccountId && token) {
        const up = await uploadVideoToAdAccount(
          fbAdAccountId, token, absoluteUrl,
          'SmartMark Generated Video', 'Generated by SmartMark'
        );
        fbVideoId = up?.id || null;
      }
    } catch {}

    return res.json({
      videoUrl: publicVideoUrl,
      absoluteVideoUrl: absoluteUrl,
      fbVideoId,
      script,
      ctaText,
      voice: 'alloy',
      video: { url: publicVideoUrl, script, overlayText: ctaText, voice: 'alloy', variant: 1 }
    });
  } catch (err) {
    if (!res.headersSent)
      return res.status(500).json({ error: 'Failed to generate video ad', detail: err?.message || 'Unknown error' });
  }
});

/* --------------------- IMAGE: search + overlay --------------------- */
router.post('/generate-image-from-prompt', async (req, res) => {
  try {
    const { regenerateToken = '' } = req.body;
    const top = req.body || {};
    const answers = top.answers || top;
    const url = answers.url || top.url || '';
    const industry = answers.industry || top.industry || '';

    const keyword = getImageKeyword(industry, url);

    let photos = [];
    try {
      const r = await axios.get(PEXELS_IMG_BASE, {
        headers: { Authorization: PEXELS_API_KEY },
        params: { query: keyword, per_page: 35, cb: Date.now() + (regenerateToken || '') },
        timeout: 4500
      });
      photos = r.data.photos || [];
    } catch {
      return res.status(500).json({ error: 'Image search failed' });
    }
    if (!photos.length) return res.status(404).json({ error: 'No images found.' });

    const seed = regenerateToken || answers?.businessName || keyword || Date.now();
    let idxHash = 0; for (const c of String(seed)) idxHash = (idxHash*31 + c.charCodeAt(0))>>>0;
    const idx = (idxHash % photos.length);

    const img = photos[idx];
    const baseUrl = img.src.large2x || img.src.original || img.src.large;

    const headlineHint = overlayTitleFromAnswers(answers, keyword);
    const ctaHint = pickFromAllowedCTAs(answers, seed);

    let finalUrl = baseUrl;
    try {
      const { publicUrl } = await buildOverlayImage({ imageUrl: baseUrl, headlineHint, ctaHint, seed });
      finalUrl = publicUrl;
    } catch {
      // fallback to raw
    }

    res.json({ imageUrl: finalUrl, photographer: img.photographer, pexelsUrl: img.url, keyword, totalResults: photos.length, usedIndex: idx });
  } catch (e) {
    res.status(500).json({ error: 'Failed to fetch stock image', detail: e.message });
  }
});

module.exports = router;
