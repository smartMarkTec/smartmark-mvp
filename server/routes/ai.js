// server/routes/ai.js
'use strict';

const express = require('express');
const router = express.Router();
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const sharp = require('sharp');
const { v4: uuidv4 } = require('uuid');
const FormData = require('form-data');
const child_process = require('child_process');
const util = require('util');
const exec = util.promisify(child_process.exec);

const { getFbUserToken } = require('../tokenStore');

// ---------- helpers ----------
function absolutePublicUrl(relativePath) {
  const base = process.env.PUBLIC_BASE_URL || process.env.RENDER_EXTERNAL_URL || 'https://smartmark-mvp.onrender.com';
  if (!relativePath) return '';
  if (/^https?:\/\//i.test(relativePath)) return relativePath;
  return `${base}${relativePath}`;
}
function getUserToken(req) {
  return req?.body?.userAccessToken || getFbUserToken() || null;
}
async function uploadVideoToAdAccount(adAccountId, userAccessToken, fileUrl, name = 'SmartMark Video', description = 'Generated by SmartMark') {
  const url = `https://graph.facebook.com/v23.0/act_${String(adAccountId).replace(/^act_/, '')}/advideos`;
  const form = new FormData();
  form.append('file_url', fileUrl);
  form.append('name', name);
  form.append('description', description);
  const resp = await axios.post(url, form, { headers: form.getHeaders(), params: { access_token: userAccessToken } });
  return resp.data;
}

// ---------- OpenAI / Pexels ----------
const { OpenAI } = require('openai');
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const PEXELS_API_KEY = process.env.PEXELS_API_KEY;
const PEXELS_BASE_URL = 'https://api.pexels.com/v1/search';
const PEXELS_VIDEO_BASE = 'https://api.pexels.com/videos/search';

router.get('/test', (_req, res) => res.json({ msg: 'AI route is working!' }));

// ---------- training context ----------
const DATA_DIR = path.join(__dirname, '../data');
const ALLOWED_EXT = new Set(['.txt', '.md', '.markdown', '.json']);
const MAX_FILE_MB = 1.5;
const MAX_TOTAL_CHARS = 45_000;

function loadTrainingContext() {
  if (!fs.existsSync(DATA_DIR)) return '';
  const files = fs.readdirSync(DATA_DIR)
    .map(f => path.join(DATA_DIR, f))
    .filter(full => {
      const ext = path.extname(full).toLowerCase();
      try {
        const st = fs.statSync(full);
        return st.isFile() && ALLOWED_EXT.has(ext) && st.size <= MAX_FILE_MB * 1024 * 1024;
      } catch { return false; }
    });

  let ctx = '';
  for (const f of files) {
    try {
      const ext = path.extname(f).toLowerCase();
      let text = fs.readFileSync(f, 'utf8');
      if (ext === '.json') { try { text = JSON.stringify(JSON.parse(text)); } catch {} }
      if (!text.trim()) continue;
      const block = `\n\n### SOURCE: ${path.basename(f)}\n${text}\n`;
      if (ctx.length + block.length <= MAX_TOTAL_CHARS) ctx += block;
    } catch {}
  }
  return ctx.trim();
}
let customContext = loadTrainingContext();

// ---------- scraper ----------
async function getWebsiteText(url) {
  try {
    const clean = String(url || '').trim();
    if (!clean || !/^https?:\/\//i.test(clean)) throw new Error('Invalid URL');
    const { data, headers } = await axios.get(clean, { timeout: 7000, maxRedirects: 3, validateStatus: s => s < 400 });
    if (!headers['content-type']?.includes('text/html')) throw new Error('Not an HTML page');

    const body = String(data)
      .replace(/<script[\s\S]*?<\/script>/gi, '')
      .replace(/<style[\s\S]*?<\/style>/gi, '')
      .replace(/<[^>]+>/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();

    if (body.length < 200 || /cloudflare|access denied/i.test(body)) throw new Error('blocked/short');
    return body.slice(0, 3500);
  } catch (e) {
    console.warn('scrape fail:', url || '(empty)', e.message);
    return '';
  }
}

// ---------- ad copy ----------
router.post('/generate-ad-copy', async (req, res) => {
  const { description = '', businessName = '', url = '' } = req.body;
  if (!description && !businessName && !url) return res.status(400).json({ error: 'Please provide at least a description.' });

  let prompt =
`You are an expert direct-response ad copywriter.
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}Write only the exact words for a spoken video ad script (45–55 words). Hook → benefit → strong CTA. Friendly, trustworthy, conversion-focused.`;
  if (description) prompt += `\nBusiness Description: ${description}`;
  if (businessName) prompt += `\nBusiness Name: ${businessName}`;
  if (url) prompt += `\nWebsite: ${url}`;
  prompt += `\nOutput ONLY the script text.`;

  try {
    const r = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 120
    });
    res.json({ adCopy: r.choices?.[0]?.message?.content?.trim() || '' });
  } catch (e) {
    console.error('adcopy fail:', e?.response?.data || e.message);
    res.status(500).json({ error: 'Failed to generate ad copy' });
  }
});

// ---------- audience helpers ----------
const DEFAULT_AUDIENCE = {
  brandName: '', demographic: '', ageRange: '18-65',
  location: 'US', interests: 'Business, Restaurants', fbInterestIds: [], summary: ''
};

async function extractKeywords(text) {
  const prompt = `
Extract up to 6 compact keywords (one or two words each) from this text that would be useful Facebook interest seeds.
Return them as a comma-separated list ONLY. No extra words.

TEXT:
"""${(text || '').slice(0, 3000)}"""`.trim();

  try {
    const r = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 40,
      temperature: 0.2
    });
    return (r.choices?.[0]?.message?.content || '')
      .replace(/[\n.]/g, '')
      .toLowerCase()
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);
  } catch { return []; }
}

async function getFbInterestIds(keywords, fbToken) {
  const out = [];
  for (const k of keywords) {
    try {
      const r = await axios.get('https://graph.facebook.com/v18.0/search', {
        params: { type: 'adinterest', q: k, access_token: fbToken, limit: 1 }
      });
      if (r.data?.data?.[0]?.id) out.push({ id: r.data.data[0].id, name: r.data.data[0].name });
    } catch {}
  }
  return out;
}

router.post('/detect-audience', async (req, res) => {
  const { url } = req.body;
  const fbToken = req.body.fbToken || getFbUserToken();
  if (!url) return res.status(400).json({ error: 'Missing URL' });

  const websiteText = await getWebsiteText(url);
  const safe = websiteText.length > 100 ? websiteText : '[WEBSITE TEXT UNAVAILABLE]';

  const prompt = `
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}
Analyze this website's homepage content and answer ONLY in the following JSON format:
{
  "brandName": "",
  "demographic": "",
  "ageRange": "",
  "location": "",
  "interests": "",
  "summary": ""
}
Website homepage text:
"""${safe}"""`.trim();

  try {
    const r = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 220,
      temperature: 0.3
    });

    const txt = r.choices?.[0]?.message?.content?.trim() || '{}';
    let aud;
    try {
      const m = txt.match(/\{[\s\S]*\}/);
      aud = JSON.parse(m ? m[0] : txt);
      aud = {
        brandName: aud.brandName || '',
        demographic: aud.demographic || '',
        ageRange: /^\d{2}-\d{2}$/.test(aud.ageRange || '') ? aud.ageRange : '18-65',
        location: (aud.location || 'US').toString().trim().toUpperCase() || 'US',
        interests: aud.interests || 'Business, Restaurants',
        summary: aud.summary || ''
      };
    } catch {
      return res.json({ audience: DEFAULT_AUDIENCE });
    }

    if (fbToken) {
      const kws = await extractKeywords(websiteText);
      const fb = await getFbInterestIds(kws, fbToken);
      aud.fbInterestIds = fb.map(i => i.id);
      aud.fbInterestNames = fb.map(i => i.name);
    } else {
      aud.fbInterestIds = [];
      aud.fbInterestNames = [];
    }
    res.json({ audience: aud });
  } catch {
    res.json({ audience: DEFAULT_AUDIENCE });
  }
});

// ---------- image keyword map ----------
const IMAGE_KEYWORD_MAP = [
  { match: ['protein powder','protein','supplement','muscle','fitness','gym'], keyword: 'gym workout' },
  { match: ['clothing','fashion','apparel','accessory'], keyword: 'fashion model' },
  { match: ['makeup','cosmetic','skincare'], keyword: 'makeup application' },
  { match: ['hair','shampoo'], keyword: 'hair care' },
  { match: ['food','pizza','burger','meal','snack'], keyword: 'delicious food' },
  { match: ['baby','kids','toys'], keyword: 'happy children' },
  { match: ['pet','dog','cat'], keyword: 'pet dog cat' },
  { match: ['electronics','phone','laptop','tech'], keyword: 'tech gadgets' },
  { match: ['home','kitchen','decor'], keyword: 'modern home' },
  { match: ['art','painting','craft'], keyword: 'painting art' },
  { match: ['coffee','cafe'], keyword: 'coffee shop' }
];

function getImageKeyword(industry = '', url = '') {
  const input = `${industry} ${url}`.toLowerCase();
  for (const row of IMAGE_KEYWORD_MAP) if (row.match.some(m => input.includes(m))) return row.keyword;
  return industry || 'ecommerce';
}

// ---------- category map & sane copy ----------
const INDUSTRY_MAP = [
  { names: ['clothing','fashion','accessory','apparel','shoes','jewelry','watches','bags','handbags','backpacks','luggage','hats','sunglasses'], category: 'Fashion & Accessories', pexels: 'fashion clothing accessories' },
  { names: ['makeup','cosmetics','skincare','haircare','perfume','fragrance','grooming','beauty'], category: 'Beauty & Personal Care', pexels: 'makeup beauty skincare' },
  { names: ['gym','fitness','workout','sports','exercise','weights','protein','supplement','outdoor','yoga','biking','running','health coaching','wellness','coach','personal trainer'], category: 'Fitness, Sports & Outdoors', pexels: 'fitness gym workout exercise' },
  { names: ['furniture','home','decor','kitchen','appliance','bedding','bath','art','lamp','rugs','cookware','table','sofa','bed'], category: 'Home, Kitchen & Decor', pexels: 'home kitchen decor' },
  { names: ['phone','tablet','laptop','computer','electronics','gadgets','wearable','smartwatch','headphones','camera','drone','tech','device'], category: 'Electronics & Gadgets', pexels: 'electronics gadgets tech' },
  { names: ['snack','food','meal kit','grocery','coffee','tea','alcohol','wine','beer','spirits','beverage','drink'], category: 'Food & Beverage', pexels: 'food drink meal' },
  { names: ['baby','kids','toys','stroller','child','children','pet','dog','cat','animal','pet food','pet toy'], category: 'Baby, Kids & Pets', pexels: 'kids baby pets toys' },
  { names: ['vitamin','supplement','medical','health','wellness','mental','therapy','life coach','coaching','self-care','personal development'], category: 'Health & Wellness', pexels: 'wellness health happy' },
  { names: ['art','craft','diy','music','instrument','collectible','hobby','painting','drawing'], category: 'Arts, Crafts & Hobbies', pexels: 'art craft hobby' },
  { names: ['course','ebook','subscription','box','event','ticket','digital','learning','online'], category: 'Digital, Subscription & Services', pexels: 'digital online learning' }
];
function mapIndustry(inputRaw = '') {
  const input = String(inputRaw || '').toLowerCase();
  for (const cat of INDUSTRY_MAP) if (cat.names.some(keyword => input.includes(keyword))) return { category: cat.category, pexels: cat.pexels };
  return { category: 'General E-Commerce', pexels: 'shopping ecommerce online' };
}

const FALLBACK_HEADLINES = {
  'Fashion & Accessories': ['New Arrivals', 'Everyday Style', 'Modern Essentials', 'Wardrobe Refresh'],
  'Beauty & Personal Care': ['Glow Every Day', 'Your Best Skin', 'Beauty That Works'],
  'Fitness, Sports & Outdoors': ['Move Better', 'Train Smarter', 'Strong Starts Here'],
  'Home, Kitchen & Decor': ['Make Home Yours', 'Refresh Your Space', 'Cozy Looks Good'],
  'Electronics & Gadgets': ['Upgrade Your Tech', 'Smart Starts Here', 'Next-Gen Gear'],
  'Food & Beverage': ['Good Food Fast', 'Taste Something Great', 'Delicious Delivered'],
  'Baby, Kids & Pets': ['For Little Moments', 'Happy Pets', 'Family Favorites'],
  'Health & Wellness': ['Feel Your Best', 'Wellness That Works'],
  'Arts, Crafts & Hobbies': ['Create Today', 'Make Something', 'Craft Your Way'],
  'Digital, Subscription & Services': ['Unlock More', 'Join In', 'Get Access'],
  'General E-Commerce': ['Find What You Love', 'Great Picks Today', 'Everyday Essentials']
};
const FALLBACK_CTA = {
  'Fashion & Accessories': ['Shop Now', 'See The Edit', 'Explore'],
  'Beauty & Personal Care': ['Start Now', 'See Routine', 'Explore'],
  'Fitness, Sports & Outdoors': ['Start Today', 'Get Moving', 'Explore'],
  'Home, Kitchen & Decor': ['Shop Home', 'See More', 'Explore'],
  'Electronics & Gadgets': ['Upgrade Now', 'See More', 'Explore'],
  'Food & Beverage': ['Order Now', 'Taste It', 'See Menu'],
  'Baby, Kids & Pets': ['Shop Now', 'See Picks', 'Explore'],
  'Health & Wellness': ['Start Now', 'Learn More', 'Explore'],
  'Arts, Crafts & Hobbies': ['Create Now', 'See Kits', 'Explore'],
  'Digital, Subscription & Services': ['Join Now', 'Start Free', 'Explore'],
  'General E-Commerce': ['Shop Now', 'Learn More', 'Explore']
};
const BANNED_TERMS = /\b(unisex|global|vibes?|forward|finds?|chic|bespoke|avant|couture)\b/i;

function seededPick(arr, seed) {
  let h = 0; for (const c of String(seed || '')) h = (h * 31 + c.charCodeAt(0)) >>> 0;
  return arr[h % arr.length];
}
function cleanHeadline(h) {
  h = String(h || '').replace(/[^a-z0-9 &\-]/gi, ' ').replace(/\s+/g, ' ').trim();
  if (!h || BANNED_TERMS.test(h)) return '';
  const words = h.split(' ');
  if (words.length < 2 || words.length > 4) return '';
  const okNoun = /\b(style|fashion|beauty|skin|gear|home|decor|tech|gadget|food|taste|pet|kids?|wellness|art|craft|tools?|deals?|gifts?|essentials?|sale|collection|edit|look|routine|arrivals)\b/i.test(h);
  if (!okNoun) return '';
  return h.toUpperCase();
}
function cleanCTA(c) {
  c = String(c || '').replace(/[^a-z0-9 &\-]/gi, ' ').replace(/\s+/g, ' ').trim();
  if (!c) return '';
  let words = c.split(' ').slice(0, 3).join(' ');
  if (!/[.!?]$/.test(words)) words += '!';
  return words.charAt(0).toUpperCase() + words.slice(1);
}
function escSVG(s) {
  return String(s || '')
    .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;').replace(/'/g,'&apos;');
}
function fontForHeadline(text) {
  const len = (text || '').length;
  if (len <= 14) return 56;
  if (len <= 20) return 50;
  if (len <= 26) return 44;
  return 38;
}
function chooseTemplate(seedStr = '') {
  let h = 0; for (const c of String(seedStr)) h = (h * 31 + c.charCodeAt(0)) >>> 0;
  return (h % 4) + 1;
}

// ---------- overlay builder (varied templates, CTA slightly larger) ----------
async function buildOverlayImage({ imageUrl, answers = {}, url = '', seed = '' }) {
  const { category } = mapIndustry(answers?.industry || '');
  const brand = (answers?.businessName || '').toUpperCase().slice(0, 30);

  let websiteKeywords = [];
  if (url && /^https?:\/\//i.test(url)) {
    try { websiteKeywords = await extractKeywords(await getWebsiteText(url)); } catch {}
  }
  const keysToShow = ['industry','businessName','url', ...Object.keys(answers).filter(k => !['industry','businessName','url'].includes(k))];
  const formInfo = keysToShow.map(k => answers[k] && `${k}: ${answers[k]}`).filter(Boolean).join('\n');

  let headline = '';
  let cta = '';
  try {
    const prompt = `
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}
Write overlay copy for a stock ad image. Keep it normal and generic if unsure.
- Headline: 2–4 words, natural (avoid awkward words like "unisex", "global", "finds", "forward", "chic").
- CTA label: 2–3 words, ends with "!". No button-emoji style.
Return ONLY JSON:
{"headline":"...","cta":"..."}
BUSINESS:
${formInfo}
WEBSITE KEYWORDS: [${websiteKeywords.join(', ')}]`.trim();

    const r = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: 'Output ONLY valid JSON with keys headline and cta. No explanations.' },
        { role: 'user', content: prompt }
      ],
      max_tokens: 60,
      temperature: 0.2
    });
    const raw = r.choices?.[0]?.message?.content?.trim() || '';
    const parsed = JSON.parse(raw.match(/\{[\s\S]*\}/)?.[0] || raw);
    headline = cleanHeadline(parsed.headline);
    cta = cleanCTA(parsed.cta);
  } catch {}

  if (!headline) headline = seededPick(FALLBACK_HEADLINES[category] || FALLBACK_HEADLINES['General E-Commerce'], brand || seed || Date.now()).toUpperCase();
  if (!cta) cta = cleanCTA(seededPick(FALLBACK_CTA[category] || FALLBACK_CTA['General E-Commerce'], brand || seed || Date.now()));

  const W = 1200, H = 627;
  const imgRes = await axios.get(imageUrl, { responseType: 'arraybuffer' });
  const baseBuf = await sharp(imgRes.data).resize(W, H, { fit: 'cover' }).jpeg({ quality: 92 }).toBuffer();
  const base64 = baseBuf.toString('base64');

  const ACCENT_A = '#14e7b9';
  const DARK = '#0b0d10';
  const LIGHT = '#f2f5f6';
  const fontSize = fontForHeadline(headline);
  const t = chooseTemplate(seed || brand || headline || Date.now());

  const svg =
`<svg width="${W}" height="${H}" viewBox="0 0 ${W} ${H}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="gradA" x1="0" y1="0" x2="1" y2="0">
      <stop offset="0%" stop-color="${DARK}" stop-opacity="0.85"/>
      <stop offset="100%" stop-color="#1b2026" stop-opacity="0.45"/>
    </linearGradient>
    <linearGradient id="gradB" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="#00000000"/>
      <stop offset="100%" stop-color="#000000aa"/>
    </linearGradient>
    <filter id="blurGlass"><feGaussianBlur stdDeviation="8"/></filter>
    <filter id="shadow"><feDropShadow dx="0" dy="2" stdDeviation="6" flood-color="#00000088"/></filter>
  </defs>

  <image href="data:image/jpeg;base64,${base64}" x="0" y="0" width="${W}" height="${H}"/>

  ${t === 1 ? `
    <rect x="0" y="0" width="${W}" height="${H}" fill="url(#gradB)"/>
    <g transform="skewX(-8)">
      <rect x="24" y="70" rx="18" width="${W-48}" height="120" fill="url(#gradA)" filter="url(#shadow)"/>
    </g>
    <text x="${W/2}" y="150" text-anchor="middle" font-family="Times New Roman, Times, serif"
          font-size="${fontSize}" font-weight="700" fill="${LIGHT}" letter-spacing="2"
          style="paint-order: stroke; stroke: #ffffff44; stroke-width: 0.8;">${escSVG(headline)}</text>
    <g>
      <rect x="${W/2-150}" y="200" width="300" height="40" rx="20" fill="none" stroke="${LIGHT}" stroke-width="2"/>
      <text x="${W/2}" y="229" text-anchor="middle" font-family="Helvetica, Arial, sans-serif"
            font-size="22" font-weight="800" fill="${LIGHT}" letter-spacing="1">${escSVG(cta)}</text>
    </g>
    ${brand ? `<text x="30" y="${H-24}" font-family="Helvetica, Arial, sans-serif" font-size="18" font-weight="700" fill="#e6eef2aa">${escSVG(brand)}</text>` : ''}
  ` : ''}

  ${t === 2 ? `
    <rect x="0" y="${H-150}" width="${W}" height="150" fill="url(#gradB)"/>
    <text x="40" y="${H-60}" text-anchor="start" font-family="Times New Roman, Times, serif"
          font-size="${fontSize}" font-weight="700" fill="${LIGHT}" letter-spacing="2">${escSVG(headline)}</text>
    <text x="${W-40}" y="${H-56}" text-anchor="end" font-family="Helvetica, Arial, sans-serif"
          font-size="22" font-weight="800" fill="${ACCENT_A}" letter-spacing="1" text-decoration="underline">${escSVG(cta)}</text>
    ${brand ? `<text x="40" y="52" font-family="Helvetica, Arial, sans-serif" font-size="18" font-weight="700" fill="#ffffffcc">${escSVG(brand)}</text>` : ''}
  ` : ''}

  ${t === 3 ? `
    <rect x="${W/2-430}" y="140" width="860" height="180" rx="22" fill="#ffffff22" filter="url(#shadow)"/>
    <rect x="${W/2-430}" y="140" width="860" height="180" rx="22" fill="#ffffff11" filter="url(#blurGlass)"/>
    <text x="${W/2}" y="220" text-anchor="middle" font-family="Times New Roman, Times, serif"
          font-size="${fontSize}" font-weight="700" fill="${LIGHT}" letter-spacing="1.5"
          style="paint-order: stroke; stroke: #00000055; stroke-width: 1.2;">${escSVG(headline)}</text>
    <text x="${W/2}" y="260" text-anchor="middle" font-family="Helvetica, Arial, sans-serif"
          font-size="24" font-weight="800" fill="${ACCENT_A}" letter-spacing="1">${escSVG(cta)}</text>
    ${brand ? `<text x="${W-30}" y="${H-24}" text-anchor="end" font-family="Helvetica, Arial, sans-serif" font-size="18" font-weight="700" fill="#e6eef2aa">${escSVG(brand)}</text>` : ''}
  ` : ''}

  ${t === 4 ? `
    <polygon points="0,0 ${W*0.58},0 ${W*0.42},160 0,160" fill="${ACCENT_A}"/>
    <text x="28" y="108" text-anchor="start" font-family="Times New Roman, Times, serif"
          font-size="${fontSize}" font-weight="700" fill="#0b1417" letter-spacing="2">${escSVG(headline)}</text>
    <text x="${W-110}" y="${H-70}" text-anchor="middle" font-family="Helvetica, Arial, sans-serif"
          font-size="16" font-weight="800" fill="${LIGHT}" letter-spacing="1">${escSVG(cta)}</text>
    ${brand ? `<text x="${W-30}" y="38" text-anchor="end" font-family="Helvetica, Arial, sans-serif" font-size="18" font-weight="700" fill="#0b1417">${escSVG(brand)}</text>` : ''}
  ` : ''}
</svg>`;

  const outDir = process.env.RENDER ? '/tmp/generated' : path.join(__dirname, '../public/generated');
  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
  const file = `${uuidv4()}.jpg`;
  fs.writeFileSync(path.join(outDir, file), await sharp(Buffer.from(svg)).jpeg({ quality: 95 }).toBuffer());
  return { publicUrl: `/generated/${file}`, absoluteUrl: absolutePublicUrl(`/generated/${file}`) };
}

// ---------- music (server/Music/music) ----------
function findMusicDir() {
  const candidates = [
    path.join(__dirname, '..', 'Music', 'music'),
    path.join(__dirname, '..', 'music', 'music'),
    path.join(__dirname, '..', 'Music'),
    path.join(__dirname, '..', 'music'),
    path.join(__dirname, '..', '..', 'Music', 'music'),
    path.join(__dirname, '..', '..', 'music', 'music')
  ];
  for (const p of candidates) {
    try { if (fs.existsSync(p) && fs.statSync(p).isDirectory()) return p; } catch {}
  }
  return null;
}
function pickMusicFile(keywords = []) {
  const base = findMusicDir();
  if (!base) return null;
  const files = fs.readdirSync(base).filter(f => /\.mp3$/i.test(f));
  if (!files.length) return null;

  const lower = files.map(f => f.toLowerCase());
  for (const kw of keywords.map(x => String(x).toLowerCase())) {
    let i = lower.findIndex(f => f === `${kw}.mp3`);
    if (i !== -1) return path.join(base, files[i]);
    i = lower.findIndex(f => f.includes(kw));
    if (i !== -1) return path.join(base, files[i]);
  }
  return path.join(base, files[0]);
}

// ---------- util ----------
const TTS_VOICE = 'alloy';
function withTimeout(promise, ms, msg = 'Timeout') {
  return Promise.race([promise, new Promise((_, rej) => setTimeout(() => rej(new Error(msg)), ms))]);
}
async function downloadFileWithTimeout(url, dest, timeoutMs = 30000, maxSizeMB = 5) {
  return new Promise((resolve, reject) => {
    if (!url || !/^https?:\/\//i.test(String(url))) return reject(new Error('Invalid clip URL'));
    const writer = fs.createWriteStream(dest);
    let timedOut = false;
    const timeout = setTimeout(() => { timedOut = true; writer.close(); try { fs.unlinkSync(dest); } catch {}; reject(new Error('Download timed out')); }, timeoutMs);
    axios({ url, method: 'GET', responseType: 'stream' })
      .then(resp => {
        let bytes = 0;
        resp.data.on('data', ch => {
          bytes += ch.length;
          if (bytes > maxSizeMB * 1024 * 1024 && !timedOut) { timedOut = true; writer.close(); try { fs.unlinkSync(dest); } catch {}; clearTimeout(timeout); reject(new Error('File too large')); }
        });
        resp.data.pipe(writer);
        writer.on('finish', () => { clearTimeout(timeout); if (!timedOut) resolve(dest); });
        writer.on('error', err => { clearTimeout(timeout); try { fs.unlinkSync(dest); } catch {}; if (!timedOut) reject(err); });
      })
      .catch(err => { clearTimeout(timeout); try { fs.unlinkSync(dest); } catch {}; reject(err); });
  });
}

const CTA_LIBRARY = {
  'Fashion & Accessories': ['Shop New Styles', 'See The Edit', 'Style Upgrade'],
  'Beauty & Personal Care': ['Glow Up', 'Fresh Skin', 'New Routine'],
  'Fitness, Sports & Outdoors': ['Get Fit Fast', 'Start Training', 'Crush Goals'],
  'Home, Kitchen & Decor': ['Refresh Your Home', 'Upgrade Your Space', 'Make It Cozy'],
  'Electronics & Gadgets': ['Upgrade Tech', 'Smart Upgrade', 'Power Your Day'],
  'Food & Beverage': ['Order Today', 'Taste The Good', 'Hungry? Order'],
  'Baby, Kids & Pets': ['Happy Pets', 'For Little Ones', 'Playtime Ready'],
  'Health & Wellness': ['Feel Your Best', 'Start Healing', 'Stress Less'],
  'Arts, Crafts & Hobbies': ['Create Today', 'Make Something', 'Art Starts Here'],
  'Digital, Subscription & Services': ['Start Free Trial', 'Unlock Access', 'Join Today'],
  'General E-Commerce': ['Discover More', 'Get Yours', 'Try It Now']
};
function pickCategoryCTA(category = 'General E-Commerce', seed = '') {
  const list = CTA_LIBRARY[category] || CTA_LIBRARY['General E-Commerce'];
  let h = 0; for (const c of String(seed || Date.now())) h = (h * 31 + c.charCodeAt(0)) >>> 0;
  const choice = list[h % list.length] || 'Discover More';
  const trimmed = choice.split(/\s+/).slice(0, 3).join(' ');
  return /!$/.test(trimmed) ? trimmed : (trimmed + '!');
}

// ---------- video generation (EXACT 15s voice + visuals; overlay 4s) ----------
router.post('/generate-video-ad', async (req, res) => {
  res.setHeader('Content-Type', 'application/json');
  try {
    const { url = '', answers = {}, regenerateToken = '' } = req.body;

    const token = getUserToken(req);
    const fbAdAccountId =
      req.body.fbAdAccountId || req.query.adAccountId || req.headers['x-fb-ad-account-id'] || null;

    // EXACT 15s output
    const VIDEO = { W: 640, H: 360, FPS: 24, CLIP: 5, FINAL: 15 };
    const TO = { PEXELS: 30000, DL: 45000, SCALE: 45000, CONCAT: 30000, TRIM: 20000, OVERMUX: 90000, FPROBE: 8000, ATEMPO: 15000 };

    const productType = answers?.industry || answers?.productType || '';
    const { category, pexels } = mapIndustry(productType);
    const overlayText = answers?.cta ? answers.cta : pickCategoryCTA(category, regenerateToken);

    // search term
    let termParts = [pexels];
    if (productType && !pexels.includes(productType.toLowerCase())) termParts.push(productType);
    if (url && /^https?:\/\//i.test(url)) {
      try { const tx = await withTimeout(getWebsiteText(url), 8000, 'site kw timeout'); termParts.push(...(await extractKeywords(tx)).slice(0, 2)); } catch {}
    }
    const sanitize = s => String(s || '').toLowerCase().replace(/['"]/g, '').replace(/[^a-z0-9\s]/g, ' ').replace(/\s+/g, ' ').trim();
    const term = sanitize([...new Set(termParts.filter(Boolean))].slice(0, 2).join(' ')) || 'shopping';

    // fetch stock clips
    let clips = [];
    try {
      const r = await withTimeout(
        axios.get(PEXELS_VIDEO_BASE, { headers: { Authorization: PEXELS_API_KEY }, params: { query: term, per_page: 70, cb: Date.now() + (regenerateToken || '') } }),
        TO.PEXELS, 'Pexels API timed out'
      );
      clips = r.data.videos || [];
    } catch (e) {
      console.error('Pexels vid fetch failed', e?.response?.data || e.message);
      return res.status(500).json({ error: 'Stock video fetch failed', detail: e.message });
    }
    if (!clips?.length) return res.status(404).json({ error: 'No stock videos found' });

    // candidate links
    let candidates = [];
    for (const v of clips) {
      const files = (v.video_files || [])
        .filter(f => f?.link && /\.mp4(\?|$)/i.test(f.link))
        .sort((a,b) => (a.width || 9999) - (b.width || 9999));
      const best = files.find(f => f.quality === 'sd') || files[0];
      if (best?.link) candidates.push(best.link);
    }
    candidates = Array.from(new Set(candidates));
    if (candidates.length < 3) return res.status(404).json({ error: 'Not enough usable clips' });

    // work dir
    const tmp = path.join(__dirname, '../tmp');
    if (!fs.existsSync(tmp)) fs.mkdirSync(tmp, { recursive: true });

    // download + scale 3x5s
    const paths = [];
    let p = 0;
    while (paths.length < 3 && p < candidates.length) {
      const src = candidates[p++];
      const raw = path.join(tmp, `${uuidv4()}.mp4`);
      try {
        await withTimeout(downloadFileWithTimeout(src, raw, TO.DL, 6), TO.DL + 2000, 'download timeout');
        const scaled = raw.replace('.mp4', '_s.mp4');
        await withTimeout(
          exec(
            `ffmpeg -y -i "${raw}" ` +
            `-vf "scale=${VIDEO.W}:${VIDEO.H}:force_original_aspect_ratio=decrease,` +
            `pad=${VIDEO.W}:${VIDEO.H}:(ow-iw)/2:(oh-ih)/2,setsar=1,format=yuv420p,fps=${VIDEO.FPS}" ` +
            `-t ${VIDEO.CLIP} -r ${VIDEO.FPS} -c:v libx264 -preset superfast -crf 26 -an "${scaled}"`
          ),
          TO.SCALE, 'scale timeout'
        );
        try { fs.unlinkSync(raw); } catch {}
        paths.push(scaled);
      } catch (e) {
        try { fs.unlinkSync(raw); } catch {}
      }
    }
    if (!paths.length) return res.status(500).json({ error: 'All stock clips failed' });

    // script: ~12.5–13.5s spoken, then stretch to EXACT 15.0s
    let prompt =
      (customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : '') +
      `Write a video ad script for an online e-commerce business selling physical products.\n` +
      `Script MUST be 30–38 words (~12.5–13.5s spoken). Hook → benefit → finish with this exact CTA: '${overlayText}'.\n` +
      `ONLY the spoken words.`;
    if (productType) prompt += `\nProduct category: ${productType}`;
    if (answers && Object.keys(answers).length) {
      prompt += '\nBusiness Details:\n' + Object.entries(answers).map(([k,v]) => `${k}: ${v}`).join('\n');
    }
    if (url) prompt += `\nWebsite: ${url}`;

    let script = 'Discover what you love today. Try it now!';
    try {
      const r = await withTimeout(
        openai.chat.completions.create({ model: 'gpt-4o', messages: [{ role: 'user', content: prompt }], max_tokens: 90, temperature: 0.5 }),
        15000, 'OpenAI timeout'
      );
      script = r.choices?.[0]?.message?.content?.trim() || script;
    } catch {}

    // TTS
    const ttsPath = path.join(tmp, `${uuidv4()}.mp3`);
    try {
      const ttsRes = await withTimeout(openai.audio.speech.create({ model: 'tts-1', voice: TTS_VOICE, input: script }), 20000, 'TTS timeout');
      fs.writeFileSync(ttsPath, Buffer.from(await ttsRes.arrayBuffer()));
    } catch (e) {
      console.error('TTS failed', e);
      return res.status(500).json({ error: 'TTS generation failed', detail: e.message });
    }

    // probe helper
    const probe = async (file) => {
      try {
        const { stdout } = await withTimeout(exec(`ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 "${file}"`), TO.FPROBE, 'ffprobe timeout');
        const s = parseFloat(stdout.trim());
        return isNaN(s) ? 0 : s;
      } catch { return 0; }
    };

    // Stretch/compress VO to EXACT 15.0s: tempo = dur/target, then pad+trim
    const target = VIDEO.FINAL;
    let ttsDur = await probe(ttsPath);
    const voicePath = path.join(tmp, `${uuidv4()}_voice15.mp3`);
    if (ttsDur <= 0) { ttsDur = target; }
    let tempo = ttsDur / target;                  // duration -> 15s
    tempo = Math.max(0.5, Math.min(2.0, tempo));  // atempo bounds
    try {
      await withTimeout(
        exec(
          `ffmpeg -y -i "${ttsPath}" -filter:a "atempo=${tempo},apad=pad_dur=${target},atrim=0:${target}" -c:a aac -b:a 160k -ar 44100 "${voicePath}"`
        ),
        TO.ATEMPO, 'tempo adjust timeout'
      );
    } catch {
      // fallback: copy + trim to 15s
      await withTimeout(exec(`ffmpeg -y -i "${ttsPath}" -t ${target} -c:a aac -b:a 160k -ar 44100 "${voicePath}"`), TO.ATEMPO, 'tempo fallback timeout');
    }

    // concat video exactly 15s
    const need = Math.max(1, Math.ceil(VIDEO.FINAL / VIDEO.CLIP)); // 3
    while (paths.length < need) paths.push(paths[paths.length - 1]);

    const listPath = path.join(tmp, `${uuidv4()}.txt`);
    fs.writeFileSync(listPath, paths.slice(0, need).map(pth => `file '${pth}'`).join('\n'));

    const outDir = process.env.RENDER ? '/tmp/generated' : path.join(__dirname, '../public/generated');
    if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
    const id = uuidv4();
    const concatPath = path.join(outDir, `${id}.concat.mp4`);
    const trimmedPath = path.join(outDir, `${id}.trim.mp4`);
    const outPath = path.join(outDir, `${id}.mp4`);

    await withTimeout(exec(`ffmpeg -y -f concat -safe 0 -i "${listPath}" -c copy "${concatPath}"`), TO.CONCAT, 'concat timeout');
    await withTimeout(exec(`ffmpeg -y -i "${concatPath}" -t ${VIDEO.FINAL} -c copy "${trimmedPath}"`), TO.TRIM, 'trim timeout');

    // overlay window: ALWAYS 4s (within 3–5s), at the end
    const overlayDur = 4.0;
    const overlayStart = (VIDEO.FINAL - overlayDur).toFixed(2); // e.g., 11.00
    const overlayEnd = VIDEO.FINAL.toFixed(2);                  // 15.00
    const fontfile = '/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf';
    const safeTxt = String(overlayText).toUpperCase().replace(/[\n\r:"]/g, ' ').replace(/'/g, '').replace(/[^A-Z0-9\s!]/g, '');
    const drawText =
      (fs.existsSync(fontfile)
        ? `drawtext=fontfile='${fontfile}':text='${safeTxt}':fontcolor=white@0.96:fontsize=42:box=0:shadowcolor=black@0.7:shadowx=3:shadowy=3:x=(w-text_w)/2:y=(h-text_h)/2:enable='between(t,${overlayStart},${overlayEnd})'`
        : `drawtext=text='${safeTxt}':fontcolor=white@0.96:fontsize=42:box=0:shadowcolor=black@0.7:shadowx=3:shadowy=3:x=(w-text_w)/2:y=(h-text_h)/2:enable='between(t,${overlayStart},${overlayEnd})'`
      );

    // background music (audible + ducked), both tracks EXACT 15s
    let bgKeywords = [];
    if (productType) bgKeywords.push(productType);
    if (category) bgKeywords.push(category.split(' ')[0]);
    try { if (url) { const tx = await withTimeout(getWebsiteText(url), 6000, 'kw timeout'); bgKeywords.push(...(await extractKeywords(tx))); } } catch {}
    const bgMusicPath = pickMusicFile(bgKeywords);
    console.log('BG music file:', bgMusicPath || 'NONE');

    const musicInput = bgMusicPath ? ` -i "${bgMusicPath}"` : '';
    let filterComplex, mapArgs;
    if (bgMusicPath) {
      filterComplex =
        `[0:v]${drawText}[v];` +
        `[1:a]aformat=sample_rates=44100:channel_layouts=stereo,atrim=0:${VIDEO.FINAL},apad=pad_dur=${VIDEO.FINAL}[voice];` +
        `[2:a]aformat=sample_rates=44100:channel_layouts=stereo,apad=pad_dur=${VIDEO.FINAL},atrim=0:${VIDEO.FINAL}[bg];` +
        `[bg][voice]sidechaincompress=threshold=0.12:ratio=6:attack=6:release=180[duck];` +
        `[voice][duck]amix=inputs=2:duration=first:normalize=1[mix]`;
      mapArgs = `-map "[v]" -map "[mix]"`;
    } else {
      filterComplex =
        `[0:v]${drawText}[v];` +
        `[1:a]aformat=sample_rates=44100:channel_layouts=stereo,atrim=0:${VIDEO.FINAL},apad=pad_dur=${VIDEO.FINAL}[mix]`;
      mapArgs = `-map "[v]" -map "[mix]"`;
    }

    // Force output to 15.0s (visuals keep going until script ends; both are 15s)
    await withTimeout(
      exec(
        `ffmpeg -y -i "${trimmedPath}" -i "${voicePath}"${musicInput} ` +
        `-filter_complex "${filterComplex}" ${mapArgs} ` +
        `-t ${VIDEO.FINAL} ` + // hard cap to 15s
        `-c:v libx264 -preset superfast -crf 26 -r ${VIDEO.FPS} ` +
        `-c:a aac -b:a 160k -ar 44100 -movflags +faststart "${outPath}"`
      ),
      TO.OVERMUX, 'overlay+mux timeout'
    );

    // ensure ready
    let ok = false;
    for (let i = 0; i < 40; i++) {
      try { if (fs.statSync(outPath).size > 200000) { ok = true; break; } } catch {}
      await new Promise(r => setTimeout(r, 200));
    }
    if (!ok) return res.status(500).json({ error: 'Video output not ready' });

    // cleanup
    [concatPath, trimmedPath, ...paths, listPath].forEach(pth => { try { fs.unlinkSync(pth); } catch {} });
    try { fs.unlinkSync(ttsPath); } catch {}
    try { fs.unlinkSync(voicePath); } catch {}

    const publicVideoUrl = `/generated/${id}.mp4`;
    const absoluteUrl = absolutePublicUrl(publicVideoUrl);

    // optional FB upload
    let fbVideoId = null;
    try {
      if (fbAdAccountId && token) {
        const up = await uploadVideoToAdAccount(fbAdAccountId, token, absoluteUrl, 'SmartMark Generated Video', 'Generated by SmartMark');
        fbVideoId = up?.id || null;
      }
    } catch (e) {
      console.error('FB upload fail:', e?.response?.data || e.message);
    }

    return res.json({
      videoUrl: publicVideoUrl,
      absoluteVideoUrl: absoluteUrl,
      fbVideoId,
      video: { url: publicVideoUrl, script, overlayText, voice: TTS_VOICE },
      script,
      overlayText,
      voice: TTS_VOICE
    });
  } catch (err) {
    console.error('video route error:', err);
    if (!res.headersSent) return res.status(500).json({ error: 'Failed to generate video ad', detail: err?.message || 'Unknown error' });
  }
});

// ---------- image endpoints ----------
router.post('/generate-image-from-prompt', async (req, res) => {
  try {
    const { url = '', industry = '', regenerateToken = '', answers = {} } = req.body;
    const keyword = getImageKeyword(industry, url);

    let photos = [];
    try {
      const r = await axios.get(PEXELS_BASE_URL, {
        headers: { Authorization: PEXELS_API_KEY },
        params: { query: keyword, per_page: 100, cb: Date.now() + (regenerateToken || '') },
        timeout: 4800
      });
      photos = r.data.photos || [];
    } catch (e) {
      console.error('Pexels img fetch error:', e?.message || e);
      return res.status(500).json({ error: 'Image search failed' });
    }
    if (!photos.length) return res.status(404).json({ error: 'No images found.' });

    const idx = regenerateToken
      ? Math.abs([...regenerateToken].reduce((h, c) => (h * 31 + c.charCodeAt(0)) | 0, 0)) % photos.length
      : Math.floor(Math.random() * photos.length);

    const img = photos[idx];
    const baseUrl = img.src.large2x || img.src.original || img.src.large;

    let finalUrl = baseUrl;
    try {
      const { publicUrl } = await buildOverlayImage({ imageUrl: baseUrl, answers, url, seed: regenerateToken || answers?.businessName || '' });
      finalUrl = publicUrl;
    } catch (e) {
      console.warn('Overlay build fail; using base image:', e.message);
    }

    res.json({ imageUrl: finalUrl, photographer: img.photographer, pexelsUrl: img.url, keyword, totalResults: photos.length, usedIndex: idx });
  } catch (e) {
    console.error('image route fail:', e?.message || e);
    res.status(500).json({ error: 'Failed to fetch stock image', detail: e.message });
  }
});

// ---------- exports ----------
module.exports = router;
