// server/routes/ai.js
const express = require('express');
const router = express.Router();
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const sharp = require('sharp');
const { v4: uuidv4 } = require('uuid');
const FormData = require('form-data'); // ADD THIS
const { getFbUserToken } = require('../tokenStore');



function absolutePublicUrl(relativePath) {
  const base = process.env.PUBLIC_BASE_URL || process.env.RENDER_EXTERNAL_URL || 'https://smartmark-mvp.onrender.com';
  return relativePath.startsWith('http') ? relativePath : `${base}${relativePath}`;
}

async function uploadVideoToAdAccount(adAccountId, userAccessToken, fileUrl, name = 'SmartMark Video', description = 'Generated by SmartMark') {
  const url = `https://graph.facebook.com/v23.0/act_${String(adAccountId).replace(/^act_/, '')}/advideos`;
  const form = new FormData();
  form.append('file_url', fileUrl);
  form.append('name', name);
  form.append('description', description);

  const resp = await axios.post(url, form, {
    headers: form.getHeaders(),
    params: { access_token: userAccessToken }
  });
  // resp.data -> { id: "<VIDEO_ID>" }
  return resp.data;
}



// Load Pexels API key from environment
const PEXELS_API_KEY = process.env.PEXELS_API_KEY;

// --- Use system font for overlay (no font file needed) ---
const TextToSVG = require('text-to-svg');
const textToSvg = TextToSVG.loadSync(); // Uses default system font (Arial/sans-serif on most OS)

// ----------- UNIVERSAL TRAINING FILE LOADER -----------
const DATA_DIR = path.join(__dirname, '../data');
const ALLOWED_EXT = new Set(['.txt', '.md', '.markdown', '.json']);
const MAX_FILE_MB = 1.5;          // per-file cap
const MAX_TOTAL_CHARS = 45_000;   // total cap across files

function loadTrainingContext() {
  if (!fs.existsSync(DATA_DIR)) return '';

  const files = fs.readdirSync(DATA_DIR)
    .map(f => path.join(DATA_DIR, f))
    .filter(full => {
      const ext = path.extname(full).toLowerCase();
      try {
        const st = fs.statSync(full);
        return st.isFile() && ALLOWED_EXT.has(ext) && st.size <= MAX_FILE_MB * 1024 * 1024;
      } catch { return false; }
    });

  let context = '';
  for (const f of files) {
    try {
      const ext = path.extname(f).toLowerCase();
      let text = fs.readFileSync(f, 'utf8');
      if (ext === '.json') { try { text = JSON.stringify(JSON.parse(text), null, 0); } catch {} }
      if (!text.trim()) continue;

      const block = `\n\n### SOURCE: ${path.basename(f)}\n${text}\n`;
      if ((context.length + block.length) <= MAX_TOTAL_CHARS) {
        context += block;
        console.log(`[training] loaded: ${path.basename(f)} (${block.length} chars)`);
      } else {
        console.warn(`[training] skipped (cap): ${path.basename(f)}`);
      }
    } catch (e) {
      console.warn(`[training] failed: ${path.basename(f)} → ${e.message}`);
    }
  }
  if (!context) console.warn('[training] no training context loaded (empty/filtered).');
  return context.trim();
}

// Load once at boot:
let customContext = loadTrainingContext();

// ----------- OPENAI -----------
const { OpenAI } = require('openai');
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// ========== QUICK TEST ENDPOINT ==========
router.get('/test', (req, res) => {
  res.json({ msg: "AI route is working!" });
});

// Robust website scraping
async function getWebsiteText(url) {
  try {
    const { data, headers } = await axios.get(url, { timeout: 7000 });
    // Only allow HTML content
    if (!headers['content-type'] || !headers['content-type'].includes('text/html')) {
      throw new Error('Not an HTML page');
    }
    // Remove <script> and <style> blocks, then HTML tags, then extra whitespace
    const body = String(data)
      .replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '')
      .replace(/<style[\s\S]*?>[\s\S]*?<\/style>/gi, '')
      .replace(/<[^>]+>/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
    const lower = body.toLowerCase();
    if (
      lower.includes("cloudflare") ||
      lower.includes("access denied") ||
      lower.includes("error occurred") ||
      lower.length < 200
    ) {
      throw new Error("Failed to get usable website text (blocked or not enough content)");
    }
    return body.slice(0, 3500);
  } catch (err) {
    console.warn("Could not scrape website text for:", url, "Reason:", err.message);
    return '';
  }
}

// ========== AI: EXPERT AD COPY GENERATOR ==========
router.post('/generate-ad-copy', async (req, res) => {
  const { description = "", businessName = "", url = "" } = req.body;
  if (!description && !businessName && !url) {
    return res.status(400).json({ error: "Please provide at least a description." });
  }

  let prompt =
    `You are an expert direct-response ad copywriter.\n\n` +
    (customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : '') +
    `Write only the exact words for a spoken video ad script (45–55 words).` +
    ` Hook → benefit → strong CTA. Friendly, trustworthy, conversion-focused.\n`;

  if (description) prompt += `\nBusiness Description: ${description}`;
  if (businessName) prompt += `\nBusiness Name: ${businessName}`;
  if (url) prompt += `\nWebsite: ${url}`;
  prompt += `\nOutput ONLY the script text.`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 120,
    });
    const adCopy = response.choices?.[0]?.message?.content?.trim() || "";
    return res.json({ adCopy });
  } catch (err) {
    console.error("Ad Copy Generation Error:", err?.response?.data || err.message);
    return res.status(500).json({ error: "Failed to generate ad copy" });
  }
});



// ========== AI: AUTOMATIC AUDIENCE DETECTION ==========
const DEFAULT_AUDIENCE = {
  brandName: "",
  demographic: "",
  ageRange: "18-65",
  location: "US",
  interests: "Business, Restaurants",
  fbInterestIds: [],
  summary: ""
};

// Keyword extractor for website text
async function extractKeywords(text) {
  const prompt = `
Extract up to 6 compact keywords (one or two words each) from this text that would be useful Facebook interest seeds.
Return them as a comma-separated list ONLY. No extra words.

TEXT:
"""${(text || '').slice(0, 3000)}"""
`.trim();

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 40,
      temperature: 0.2,
    });
    return (response.choices?.[0]?.message?.content || "")
      .replace(/[\n.]/g, "")
      .toLowerCase()
      .split(",")
      .map(k => k.trim())
      .filter(Boolean);
  } catch {
    return [];
  }
}


async function getFbInterestIds(keywords, fbToken) {
  const results = [];
  for (let keyword of keywords) {
    try {
      const resp = await axios.get(
        `https://graph.facebook.com/v18.0/search`,
        {
          params: {
            type: "adinterest",
            q: keyword,
            access_token: fbToken,
            limit: 1
          }
        }
      );
      if (
        resp.data &&
        Array.isArray(resp.data.data) &&
        resp.data.data[0] &&
        resp.data.data[0].id
      ) {
        results.push({
          id: resp.data.data[0].id,
          name: resp.data.data[0].name
        });
      }
    } catch (err) {}
  }
  return results;
}

// POST /api/detect-audience
router.post('/detect-audience', async (req, res) => {
  const { url } = req.body;
  const fbToken = req.body.fbToken || getFbUserToken();
  if (!url) return res.status(400).json({ error: 'Missing URL' });

  const websiteText = await getWebsiteText(url);
  const safeWebsiteText = (websiteText && websiteText.length > 100)
    ? websiteText
    : '[WEBSITE TEXT UNAVAILABLE]';

  const prompt = `
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}
Analyze this website's homepage content and answer ONLY in the following JSON format:

{
  "brandName": "",
  "demographic": "",
  "ageRange": "",
  "location": "",
  "interests": "",
  "summary": ""
}

Website homepage text:
"""${safeWebsiteText}"""
`.trim();

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 220,
      temperature: 0.3,
    });

    const aiText = response.choices?.[0]?.message?.content?.trim();
    let audienceJson = null;
    try {
      const jsonMatch = aiText.match(/\{[\s\S]*\}/);
      audienceJson = JSON.parse(jsonMatch ? jsonMatch[0] : aiText);
      audienceJson = {
        brandName: audienceJson.brandName || "",
        demographic: audienceJson.demographic || "",
        ageRange: /^\d{2}-\d{2}$/.test(audienceJson.ageRange || "") ? audienceJson.ageRange : "18-65",
        location: typeof audienceJson.location === "string" && audienceJson.location.trim().length > 0
          ? audienceJson.location.trim().toUpperCase()
          : "US",
        interests: audienceJson.interests && String(audienceJson.interests).length > 0
          ? audienceJson.interests
          : "Business, Restaurants",
        summary: audienceJson.summary || ""
      };
    } catch {
      return res.json({ audience: DEFAULT_AUDIENCE });
    }

    if (fbToken) {
      const keywords = await extractKeywords(websiteText);
      const fbInterests = await getFbInterestIds(keywords, fbToken);
      audienceJson.fbInterestIds = fbInterests.map(i => i.id);
      audienceJson.fbInterestNames = fbInterests.map(i => i.name);
    } else {
      audienceJson.fbInterestIds = [];
      audienceJson.fbInterestNames = [];
    }

    return res.json({ audience: audienceJson });
  } catch {
    return res.json({ audience: DEFAULT_AUDIENCE });
  }
});


router.post('/generate-campaign-assets', async (req, res) => {
  try {
    const { answers = {}, url = "" } = req.body;
    if (!answers || typeof answers !== "object" || Object.keys(answers).length === 0) {
      return res.status(400).json({ error: "Missing answers" });
    }

    const websiteText = await getWebsiteText(url).catch(() => '');
    const safeWebsiteText = (websiteText && websiteText.length > 100)
      ? websiteText
      : '[WEBSITE TEXT UNAVAILABLE]';

    const surveyStr = Object.entries(answers).map(([k, v]) => `${k}: ${v}`).join('\n');

    const prompt = `
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}
You are an expert Facebook ads copywriter and creative strategist. Based only on the info below, return your answer STRICTLY in minified JSON (no markdown, no explanation, no extra words).
Required fields: headline, body, image_prompt, video_script, image_overlay_text.

Rules for "image_overlay_text":
- 7–10 words
- ALL-CAPS
- Punchy and readable on a photo
- No punctuation

Survey answers:
${surveyStr}
Website text:
"""${safeWebsiteText}"""
`.trim();

    function tryParseJson(str) {
      try {
        let cleaned = String(str).replace(/```json|```/gi, '').trim();
        const firstBrace = cleaned.indexOf('{');
        if (firstBrace > 0) cleaned = cleaned.slice(firstBrace);
        cleaned = cleaned.replace(/,\s*}/g, '}').replace(/,\s*]/g, ']');
        const lastBrace = cleaned.lastIndexOf('}');
        if (lastBrace > -1) cleaned = cleaned.slice(0, lastBrace + 1);
        return JSON.parse(cleaned);
      } catch { return null; }
    }

    let raw, result;
    try {
      const response = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          { role: "system", content: "You are a world-class Facebook ad copy, creative, and script expert. Never say you are an AI." },
          { role: "user", content: prompt }
        ],
        max_tokens: 750
      });
      raw = response.choices?.[0]?.message?.content?.trim();
      result = tryParseJson(raw);
    } catch (err) {
      console.error("Ad Campaign AI Error:", err?.response?.data || err.message);
      return res.status(500).json({ error: "AI error", detail: err.message });
    }

    if (result && typeof result === "object") {
      return res.json({
        headline: result.headline || "",
        body: result.body || "",
        image_prompt: result.image_prompt || "",
        video_script: result.video_script || "",
        image_overlay_text: result.image_overlay_text || ""
      });
    } else {
      console.error("Parse error! AI output was:", raw);
      return res.status(500).json({
        error: "Failed to parse AI response",
        aiRaw: raw || "",
        example: '{"headline":"...","body":"...","image_prompt":"...","video_script":"...","image_overlay_text":"..."}'
      });
    }
  } catch (err) {
    console.error("Unhandled campaign assets error:", err?.response?.data || err.message);
    return res.status(500).json({ error: "Unhandled error", detail: err.message });
  }
});




// ========== AI: GENERATE IMAGE FROM PROMPT (PEXELS + CATEGORY MAP) ==========

const PEXELS_BASE_URL = "https://api.pexels.com/v1/search";

// Image-specific keyword mapping for max relevance
const IMAGE_KEYWORD_MAP = [
  { match: ["protein powder","protein","supplement","muscle","fitness","gym"], keyword: "gym workout" },
  { match: ["clothing","fashion","apparel","accessory"], keyword: "fashion model" },
  { match: ["makeup","cosmetic","skincare"], keyword: "makeup application" },
  { match: ["hair","shampoo"], keyword: "hair care" },
  { match: ["food","pizza","burger","meal","snack"], keyword: "delicious food" },
  { match: ["baby","kids","toys"], keyword: "happy children" },
  { match: ["pet","dog","cat"], keyword: "pet dog cat" },
  { match: ["electronics","phone","laptop","tech"], keyword: "tech gadgets" },
  { match: ["home","kitchen","decor"], keyword: "modern home" },
  { match: ["art","painting","craft"], keyword: "painting art" },
  { match: ["coffee","cafe"], keyword: "coffee shop" },
];

function getImageKeyword(industry = "", url = "") {
  const input = `${industry} ${url}`.toLowerCase();
  for (const row of IMAGE_KEYWORD_MAP) {
    if (row.match.some(m => input.includes(m))) return row.keyword;
  }
  return industry || "ecommerce";
}

router.post('/generate-image-from-prompt', async (req, res) => {
  try {
    const { url = "", industry = "", regenerateToken = "" } = req.body;
    const keyword = getImageKeyword(industry, url);

    const perPage = 100;
    let photos = [];
    try {
      const resp = await axios.get("https://api.pexels.com/v1/search", {
        headers: { Authorization: PEXELS_API_KEY },
        params: {
          query: keyword,
          per_page: perPage,
          cb: Date.now() + (regenerateToken || "")
        },
        timeout: 4800,
      });
      photos = resp.data.photos || [];
    } catch (err) {
      console.error("Pexels fetch error:", err?.message || err);
      return res.status(500).json({ error: "Image search failed" });
    }
    if (!photos.length) {
      return res.status(404).json({ error: "No images found for this topic." });
    }
    let imgIdx = 0;
    if (regenerateToken) {
      let hash = 0;
      for (let i = 0; i < regenerateToken.length; i++) {
        hash = (hash * 31 + regenerateToken.charCodeAt(i)) % perPage;
      }
      imgIdx = Math.abs(hash) % photos.length;
    } else {
      imgIdx = Math.floor(Math.random() * photos.length);
    }
    const img = photos[imgIdx];
    return res.json({
      imageUrl: img.src.large2x || img.src.original || img.src.large,
      photographer: img.photographer,
      pexelsUrl: img.url,
      keyword,
      totalResults: photos.length,
      usedIndex: imgIdx
    });
  } catch (err) {
    console.error("AI image generation error:", err?.message || err);
    res.status(500).json({ error: "Failed to fetch stock image", detail: err.message });
  }
});


// ========== AI: GENERATE IMAGE WITH OVERLAY (AUTO AI TEXT, 4-5 WORDS, PUNCTUATION) ==========
router.post('/generate-image-with-overlay', async (req, res) => {
  try {
    const { imageUrl, answers = {}, url = "" } = req.body;
    if (!imageUrl) return res.status(400).json({ error: "imageUrl required" });

    // --- Scrape website for extra context ---
    let websiteKeywords = [];
    if (url) {
      try {
        const websiteText = await getWebsiteText(url);
        websiteKeywords = await extractKeywords(websiteText);
      } catch (e) {
        websiteKeywords = [];
      }
    }

    // Prepare context for GPT
    const keysToShow = [
      "industry", "businessName", "url",
      ...Object.keys(answers).filter(k => !["industry", "businessName", "url"].includes(k))
    ];
    const formInfo = keysToShow
      .map(k => answers[k] && `${k}: ${answers[k]}`)
      .filter(Boolean)
      .join('\n');

    // --- NEW prompt using training context + site keywords ---
    const prompt = `
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}
You are the best Facebook ad copywriter. You are Jeremy Haynes.

1) Write an overlay headline (3–5 words) and CTA (3–6 words) for a stock ad image, based ONLY on this business + website.
2) It must be specific and relevant (not generic). CTA must end with "!".

Output ONLY JSON:
{"headline":"...","cta_box":"..."}

BUSINESS FORM INFO:
${formInfo}
WEBSITE KEYWORDS: [${websiteKeywords.join(", ")}]
`.trim();

    let headline = "";
    let ctaText = "";
    try {
      const response = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          { role: "system", content: "You are a world-class Facebook ad overlay expert. Output ONLY valid JSON. Do not explain." },
          { role: "user", content: prompt }
        ],
        max_tokens: 120,
        temperature: 0.2,
      });
      const raw = response.choices?.[0]?.message?.content?.trim();
      let parsed = {};
      try { parsed = JSON.parse(raw.match(/\{[\s\S]*\}/)?.[0] || raw); } catch { parsed = {}; }
      headline = parsed.headline?.trim() || "GET MORE CLIENTS NOW!";
      ctaText = parsed.cta_box?.trim() || "BOOK YOUR FREE CALL!";
    } catch {
      headline = "AI ERROR - CONTACT SUPPORT";
      ctaText = "SEE DETAILS!";
    }
    headline = String(headline).toUpperCase();
    ctaText = String(ctaText).toUpperCase();

    // Download and fit main image
    const imgRes = await axios.get(imageUrl, { responseType: 'arraybuffer' });
    const mainW = 1100, mainH = 550;
    let baseImage = await sharp(imgRes.data)
      .resize(mainW, mainH, { fit: 'cover' })
      .toBuffer();

    // Layout
    const svgW = 1200, svgH = 627;
    const borderW = 32, borderGap = 12;
    const imgX = borderW + borderGap, imgY = borderW + borderGap;
    const imgW = svgW - (borderW + borderGap) * 2;
    const imgH = svgH - (borderW + borderGap) * 2;

    // Font/box params
    const fontFamily = 'Times New Roman, Times, serif';

    // Headline fixed params
    const HEADLINE_BOX_W = 956, HEADLINE_BOX_H = 134;
    const HEADLINE_BOX_X = svgW / 2 - HEADLINE_BOX_W / 2;
    const HEADLINE_BOX_Y = 62;
    const HEADLINE_FONT_SIZE = 45;

    // CTA params
    const CTA_BOX_W = 540, CTA_BOX_H = 70;
    const CTA_BOX_X = svgW / 2 - CTA_BOX_W / 2;
    const CTA_BOX_Y = HEADLINE_BOX_Y + HEADLINE_BOX_H + 34;
    const CTA_FONT_SIZE = 26;

    // Glassmorph blur for headline box
    const blurStrength = 15;
    const headlineImg = await sharp(baseImage)
      .extract({
        left: Math.max(0, Math.round(HEADLINE_BOX_X - imgX)),
        top: Math.max(0, Math.round(HEADLINE_BOX_Y - imgY)),
        width: Math.round(HEADLINE_BOX_W),
        height: Math.round(HEADLINE_BOX_H)
      })
      .blur(blurStrength)
      .toBuffer();

    // Glassmorph blur for CTA
    const ctaImg = await sharp(baseImage)
      .extract({
        left: Math.max(0, Math.round(CTA_BOX_X - imgX)),
        top: Math.max(0, Math.round(CTA_BOX_Y - imgY)),
        width: Math.round(CTA_BOX_W),
        height: Math.round(CTA_BOX_H)
      })
      .blur(blurStrength)
      .toBuffer();



    const headlineTextColor = "#181b20";
    const ctaTextColor = "#181b20";

    // SVG helper
    function escapeForSVG(text) {
      return String(text)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&apos;");
    }

    // Pick two distinct colors for borders
    const borderColors = ['#edead9', '#191919', '#193356']; // beige, black, navy
    let outerBorderColor = borderColors[Math.floor(Math.random() * borderColors.length)];
    let innerBorderColor = borderColors[Math.floor(Math.random() * borderColors.length)];
    while (innerBorderColor === outerBorderColor) {
      innerBorderColor = borderColors[Math.floor(Math.random() * borderColors.length)];
    }

    // --- Compose SVG ---
    const svg = `
<svg width="${svgW}" height="${svgH}" xmlns="http://www.w3.org/2000/svg">
  <!-- Outer border -->
  <rect x="7" y="7" width="${svgW-14}" height="${svgH-14}" fill="none" stroke="${outerBorderColor}" stroke-width="10" rx="34"/>
  <!-- Inner border -->
  <rect x="27" y="27" width="${svgW-54}" height="${svgH-54}" fill="none" stroke="${innerBorderColor}" stroke-width="5" rx="20"/>
  <rect x="0" y="0" width="${svgW}" height="${svgH}" fill="#edead9" rx="26"/>
  <image href="data:image/jpeg;base64,${baseImage.toString('base64')}" x="${imgX+8}" y="${imgY+8}" width="${imgW-16}" height="${imgH-16}" />
  <!-- Glassmorph headline -->
  <image href="data:image/jpeg;base64,${headlineImg.toString('base64')}" x="${HEADLINE_BOX_X}" y="${HEADLINE_BOX_Y}" width="${HEADLINE_BOX_W}" height="${HEADLINE_BOX_H}" opacity="0.97"/>
  <rect x="${HEADLINE_BOX_X}" y="${HEADLINE_BOX_Y}" width="${HEADLINE_BOX_W}" height="${HEADLINE_BOX_H}" rx="22" fill="#ffffff38"/>
  <text
    x="${svgW/2}"
    y="${HEADLINE_BOX_Y + HEADLINE_BOX_H/2 + HEADLINE_FONT_SIZE/3}"
    text-anchor="middle"
    font-family="${fontFamily}"
    font-size="${HEADLINE_FONT_SIZE}"
    font-weight="bold"
    fill="${headlineTextColor}"
    alignment-baseline="middle"
    dominant-baseline="middle"
    letter-spacing="1"
  >${escapeForSVG(headline)}</text>
  <!-- Glassmorph CTA -->
  <image href="data:image/jpeg;base64,${ctaImg.toString('base64')}" x="${CTA_BOX_X}" y="${CTA_BOX_Y}" width="${CTA_BOX_W}" height="${CTA_BOX_H}" opacity="0.97"/>
  <rect x="${CTA_BOX_X}" y="${CTA_BOX_Y}" width="${CTA_BOX_W}" height="${CTA_BOX_H}" rx="19" fill="#ffffff38"/>
  <text
    x="${svgW/2}"
    y="${CTA_BOX_Y + CTA_BOX_H/2 + CTA_FONT_SIZE/3}"
    text-anchor="middle"
    font-family="${fontFamily}"
    font-size="${CTA_FONT_SIZE}"
    font-weight="bold"
    fill="${ctaTextColor}"
    alignment-baseline="middle"
    dominant-baseline="middle"
    letter-spacing="0.5"
  >${escapeForSVG(ctaText)}</text>
</svg>`;

    // --- Compose SVG on Image ---
    const generatedPath = process.env.RENDER ? '/tmp/generated' : path.join(__dirname, '../public/generated');
    if (!fs.existsSync(generatedPath)) fs.mkdirSync(generatedPath, { recursive: true });
    const fileName = `${uuidv4()}.jpg`;
    const filePath = path.join(generatedPath, fileName);

    const outBuffer = await sharp({
      create: {
        width: svgW,
        height: svgH,
        channels: 3,
        background: "#edead9"
      }
    })
      .composite([
        { input: Buffer.from(svg), top: 0, left: 0 }
      ])
      .jpeg({ quality: 98 })
      .toBuffer();

    fs.writeFileSync(filePath, outBuffer);

    const publicUrl = `/generated/${fileName}`;
    console.log("Glass overlay image saved at:", filePath, "and served as:", publicUrl);

    return res.json({
      imageUrl: publicUrl,
      absoluteImageUrl: absolutePublicUrl(publicUrl),
      overlay: { headline, ctaText }
    });
  } catch (err) {
    console.error("Image overlay error:", err.message);
    return res.status(500).json({ error: "Failed to overlay image", detail: err.message });
  }
});

// ===== Music selection helper =====
// Folder: /server/Music.  Music files should be named like: "pizza.mp3", "gym.mp3", etc.
function pickMusicFile(keywords = []) {
  // Try to find a matching music file by keyword
  const musicDir = path.join(__dirname, '../Music');
  if (!fs.existsSync(musicDir)) return null;
  const files = fs.readdirSync(musicDir);
  // Lowercase filenames for match
  const filesLower = files.map(f => f.toLowerCase());
  for (let kw of keywords.map(x => String(x).toLowerCase())) {
    // Try exact match, then "contains"
    let idx = filesLower.findIndex(f => f === `${kw}.mp3`);
    if (idx !== -1) return path.join(musicDir, files[idx]);
    idx = filesLower.findIndex(f => f.includes(kw) && f.endsWith('.mp3'));
    if (idx !== -1) return path.join(musicDir, files[idx]);
  }
  // Default fallback (optional): first music file in folder
  if (files.length > 0) return path.join(musicDir, files[0]);
  return null;
}

// ========== AI: GENERATE VIDEO AD FOR E-COMMERCE ==========
const PEXELS_VIDEO_BASE = "https://api.pexels.com/videos/search";
const TTS_VOICE = "alloy";
const ffmpegPath = 'ffmpeg';
const child_process = require('child_process');
const util = require('util');
const exec = util.promisify(child_process.exec);
const seedrandom = require('seedrandom');

// ---- CATEGORY MAPPING ----
const INDUSTRY_MAP = [
  {
    names: [
      "clothing","fashion","accessory","apparel","shoes","jewelry","watches","bags","handbags","backpacks","luggage","hats","sunglasses"
    ],
    category: "Fashion & Accessories",
    pexels: "fashion clothing accessories"
  },
  {
    names: [
      "makeup","cosmetics","skincare","haircare","perfume","fragrance","grooming","beauty"
    ],
    category: "Beauty & Personal Care",
    pexels: "makeup beauty skincare"
  },
  {
    names: [
      "gym","fitness","workout","sports","exercise","weights","protein","supplement","outdoor","yoga","biking","running","health coaching","wellness","coach","personal trainer"
    ],
    category: "Fitness, Sports & Outdoors",
    pexels: "fitness gym workout exercise"
  },
  {
    names: [
      "furniture","home","decor","kitchen","appliance","bedding","bath","art","lamp","rugs","cookware","table","sofa","bed"
    ],
    category: "Home, Kitchen & Decor",
    pexels: "home kitchen decor"
  },
  {
    names: [
      "phone","tablet","laptop","computer","electronics","gadgets","wearable","smartwatch","headphones","camera","drone","tech","device"
    ],
    category: "Electronics & Gadgets",
    pexels: "electronics gadgets tech"
  },
  {
    names: [
      "snack","food","meal kit","grocery","coffee","tea","alcohol","wine","beer","spirits","beverage","drink"
    ],
    category: "Food & Beverage",
    pexels: "food drink meal"
  },
  {
    names: [
      "baby","kids","toys","stroller","child","children","pet","dog","cat","animal","pet food","pet toy"
    ],
    category: "Baby, Kids & Pets",
    pexels: "kids baby pets toys"
  },
  {
    names: [
      "vitamin","supplement","medical","health","wellness","mental","therapy","life coach","coaching","self-care","personal development"
    ],
    category: "Health & Wellness",
    pexels: "wellness health happy"
  },
  {
    names: [
      "art","craft","diy","music","instrument","collectible","hobby","painting","drawing"
    ],
    category: "Arts, Crafts & Hobbies",
    pexels: "art craft hobby"
  },
  {
    names: [
      "course","ebook","subscription","box","event","ticket","digital","learning","online"
    ],
    category: "Digital, Subscription & Services",
    pexels: "digital online learning"
  }
];

// Map function (returns {category, pexels})
function mapIndustry(inputRaw = "") {
  const input = String(inputRaw || "").toLowerCase();
  for (const cat of INDUSTRY_MAP) {
    if (cat.names.some(keyword => input.includes(keyword))) {
      return { category: cat.category, pexels: cat.pexels };
    }
  }
  // fallback to generic
  return { category: "General E-Commerce", pexels: "shopping ecommerce online" };
}

// Helper to timeout any promise
function withTimeout(promise, ms, errorMsg = "Timeout") {
  return Promise.race([
    promise,
    new Promise((_, reject) => setTimeout(() => reject(new Error(errorMsg)), ms))
  ]);
}

// Download with timeout and file size limit (FAST/Safe)
async function downloadFileWithTimeout(url, dest, timeoutMs = 30000, maxSizeMB = 5) {
  return new Promise((resolve, reject) => {
    const writer = fs.createWriteStream(dest);
    let timedOut = false;
    const timeout = setTimeout(() => {
      timedOut = true;
      writer.close();
      try { fs.unlinkSync(dest); } catch {}
      reject(new Error("Download timed out"));
    }, timeoutMs);

    axios({ url, method: 'GET', responseType: 'stream' })
      .then(response => {
        let bytes = 0;
        response.data.on('data', chunk => {
          bytes += chunk.length;
          if (bytes > maxSizeMB * 1024 * 1024 && !timedOut) {
            timedOut = true;
            writer.close();
            try { fs.unlinkSync(dest); } catch {}
            clearTimeout(timeout);
            reject(new Error("File too large"));
          }
        });
        response.data.pipe(writer);
        writer.on('finish', () => {
          clearTimeout(timeout);
          if (!timedOut) resolve(dest);
        });
        writer.on('error', err => {
          clearTimeout(timeout);
          try { fs.unlinkSync(dest); } catch {}
          if (!timedOut) reject(err);
        });
      })
      .catch(err => {
        clearTimeout(timeout);
        try { fs.unlinkSync(dest); } catch {}
        reject(err);
      });
  });
}

// Helper: shuffle with token for regen
function getDeterministicShuffle(arr, seed) {
  let array = [...arr];
  let random = seedrandom(seed);
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

function normalizeShortCTA(input) {
  if (!input) return "Learn More!";
  const t = input.toLowerCase();

  // Common CTA detection and replacement
  if (t.includes("website") || t.includes("purchase")) return "Visit Our Website!";
  if (t.includes("buy")) return "Buy Now!";
  if (t.includes("order")) return "Order Now!";
  if (t.includes("shop")) return "Shop Now!";
  if (t.includes("sign up") || t.includes("signup")) return "Sign Up!";
  if (t.includes("call")) return "Call Now!";
  if (t.includes("learn")) return "Learn More!";
  if (t.includes("book")) return "Book Now!";
  if (t.includes("join")) return "Join Now!";
  if (t.includes("try")) return "Try It Now!";
  if (t.includes("contact")) return "Contact Us!";
  if (t.includes("start")) return "Get Started!";
  if (t.includes("check out")) return "Check Us Out!";
  if (t.includes("subscribe")) return "Subscribe Now!";

  // Remove any trailing periods, keep short, capitalize first
  return input
    .replace(/^(visit|make|please|try|interested|contact|reach|check out|order|shop|buy|learn|call|book|join|sign up|subscribe|start)\s*(our)?\s*(website|site|now|today|us)?/i, "")
    .replace(/[\.\!]+$/, "")
    .trim()
    .split(" ")
    .slice(0, 5) // max 5 words
    .join(" ")
    .replace(/^\w/, c => c.toUpperCase()) + "!";
}


router.post('/generate-video-ad', async (req, res) => {
  res.setHeader('Content-Type', 'application/json');
  try {
    console.log("Step 1: Starting video ad generation...");

    const { url = "", answers = {}, regenerateToken = "" } = req.body;
    const productType = answers?.industry || answers?.productType || "";
    const overlayText = normalizeShortCTA(answers?.cta);

    // -------- CATEGORY MAPPING APPLIED HERE --------
    const { category, pexels } = mapIndustry(productType);

    // Step 1: Keywords for Pexels
    let videoKeywords = [pexels];
    if (productType && !pexels.includes(productType.toLowerCase())) videoKeywords.push(productType);
    if (url) {
      try {
        const websiteText = await withTimeout(getWebsiteText(url), 8000, "Website text fetch timed out");
        const siteKeywords = (await extractKeywords(websiteText)).slice(0, 2);
        videoKeywords.push(...siteKeywords);
      } catch (e) {
        console.log("Warning: website text unavailable or timeout");
      }
    }
    videoKeywords = Array.from(new Set(videoKeywords.filter(Boolean)));
    const searchTerm = videoKeywords.slice(0, 2).join(" ");
    console.log("Step 3: Pexels search term:", searchTerm);

    // Step 2: Fetch videos from Pexels
    let videoClips = [];
    try {
      const resp = await withTimeout(
        axios.get(PEXELS_VIDEO_BASE, {
          headers: { Authorization: PEXELS_API_KEY },
          params: { query: searchTerm, per_page: 70, cb: Date.now() + (regenerateToken || "") }
        }),
        30000,
        "Pexels API timed out"
      );
      videoClips = resp.data.videos || [];
    } catch (err) {
      console.error("FFMPEG ERROR: Pexels fetch failed", err?.response?.data || err.message || err);
      return res.status(500).json({ error: "Stock video fetch failed", detail: err?.message || err?.toString() });
    }
    if (!videoClips || videoClips.length < 3) {
      console.error('PEXELS returned too few videos. Response:', videoClips);
      return res.status(404).json({ error: "Not enough stock videos found" });
    }

    // Step 3: Pick 3 smallest SD mp4s from DIFFERENT videos, shuffled deterministically by token
    let candidates = [];
    for (let v of videoClips) {
      let mp4s = (v.video_files || [])
        .filter(f => f.quality === 'sd' && f.link.endsWith('.mp4'))
        .sort((a, b) => (a.width || 9999) - (b.width || 9999));
      if (mp4s[0] && !candidates.includes(mp4s[0].link)) candidates.push(mp4s[0].link);
    }
    if (candidates.length < 3) {
      return res.status(500).json({ error: "Not enough SD MP4 clips found" });
    }
    // Deterministic shuffle for regen
    const shuffled = getDeterministicShuffle(candidates, regenerateToken || `${Date.now()}_${Math.random()}`);
    const files = shuffled.slice(0, 3);

    // Step 4: Download, scale, trim (8s each, 720x404)
    const tempDir = path.join(__dirname, '../tmp');
    if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir, { recursive: true });
    const videoPaths = [];
    const TARGET_WIDTH = 720, TARGET_HEIGHT = 404, FRAMERATE = 30;
    for (let i = 0; i < files.length; i++) {
      const dest = path.join(tempDir, `${require('uuid').v4()}.mp4`);
      try {
        await withTimeout(downloadFileWithTimeout(files[i], dest, 30000, 5), 30000, "Download step timed out");
      } catch (e) {
        console.error("FFMPEG ERROR: Download step failed", e);
        return res.status(500).json({ error: "Stock video download failed", detail: e.message });
      }
      const scaledPath = dest.replace('.mp4', '_scaled.mp4');
      try {
        await withTimeout(
          exec(
            `${ffmpegPath} -y -i "${dest}" -vf "scale=${TARGET_WIDTH}:${TARGET_HEIGHT}:force_original_aspect_ratio=decrease,pad=${TARGET_WIDTH}:${TARGET_HEIGHT}:(ow-iw)/2:(oh-ih)/2,setsar=1,format=yuv420p,fps=${FRAMERATE}" -t 6 -r ${FRAMERATE} -c:v libx264 -preset superfast -crf 24 -an "${scaledPath}"`
          ),
          18000,
          "ffmpeg scaling timed out"
        );
      } catch (e) {
        fs.unlinkSync(dest);
        console.error("FFMPEG ERROR: Scaling step failed", e.stderr || e.message || e);
        return res.status(500).json({ error: "Video scaling failed", detail: e.message });
      }
      fs.unlinkSync(dest);
      videoPaths.push(scaledPath);
    }

    // Step 5: Generate GPT script (mention CTA)
    let prompt =
      (customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : '') +
      `Write a video ad script for an online e-commerce business selling physical products. ` +
      `Script MUST be 45–55 words (~15–18s spoken). Hook → benefit → end with this exact CTA: '${overlayText}'. ` +
      `No scene directions or SFX — ONLY the spoken words.`;
    if (productType) prompt += `\nProduct category: ${productType}`;
    if (answers && Object.keys(answers).length) {
      prompt += '\nBusiness Details:\n' + Object.entries(answers).map(([k, v]) => `${k}: ${v}`).join('\n');
    }
    if (url) prompt += `\nWebsite: ${url}`;
    prompt += `\nRespond ONLY with the script text.`;

    let script;
    try {
      const gptRes = await withTimeout(
        openai.chat.completions.create({
          model: 'gpt-4o',
          messages: [{ role: 'user', content: prompt }],
          max_tokens: 110,
          temperature: 0.65
        }),
        15000,
        "OpenAI GPT timed out"
      );
      script = gptRes.choices?.[0]?.message?.content?.trim() || "Shop the best products online now!";
    } catch (e) {
      console.error("FFMPEG ERROR: GPT script gen failed", e);
      return res.status(500).json({ error: "GPT script generation failed", detail: e.message });
    }


    // Step 6: Generate TTS voiceover
    let ttsPath;
    try {
      const ttsRes = await withTimeout(
        openai.audio.speech.create({
          model: 'tts-1',
          voice: TTS_VOICE,
          input: script
        }),
        15000,
        "OpenAI TTS timed out"
      );
      const ttsBuffer = Buffer.from(await ttsRes.arrayBuffer());
      ttsPath = path.join(tempDir, `${require('uuid').v4()}.mp3`);
      fs.writeFileSync(ttsPath, ttsBuffer);
    } catch (e) {
      console.error("FFMPEG ERROR: TTS step failed", e);
      return res.status(500).json({ error: "TTS generation failed", detail: e.message });
    }

    // ----- Step 1: Get TTS duration -----
    let ttsDuration = 16;
    try {
      let ffprobePath = ffmpegPath && ffmpegPath.endsWith('ffmpeg')
        ? ffmpegPath.replace(/ffmpeg$/, 'ffprobe')
        : 'ffprobe';
      const { stdout } = await withTimeout(
        exec(`${ffprobePath} -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${ttsPath}"`),
        5000,
        "ffprobe step timed out"
      );
      const seconds = parseFloat(stdout.trim());
      if (!isNaN(seconds) && seconds > 0) ttsDuration = seconds;
    } catch (e) {
      ttsDuration = 16;
    }

    // --- Step 2: Always set video to ttsDuration + 2, minimum 15s
    let finalDuration = Math.max(ttsDuration + 3.5, 15);
    const secondsPerClip = 8;
    let clipsNeeded = Math.ceil(finalDuration / secondsPerClip);
    while (videoPaths.length < clipsNeeded) {
      videoPaths.push(videoPaths[videoPaths.length - 1]);
    }
    const listPath = path.join(tempDir, `${require('uuid').v4()}.txt`);
    fs.writeFileSync(listPath, videoPaths.slice(0, clipsNeeded).map(p => `file '${p}'`).join('\n'));

    // ----- Step 3: Concatenate video files -----
    const generatedPath = process.env.RENDER ? '/tmp/generated' : path.join(__dirname, '../public/generated');
    if (!fs.existsSync(generatedPath)) fs.mkdirSync(generatedPath, { recursive: true });
    const videoId = require('uuid').v4();
    const tempConcat = path.join(generatedPath, `${videoId}.concat.mp4`);
    const tempTrimmed = path.join(generatedPath, `${videoId}.trimmed.mp4`);
    const tempOverlay = path.join(generatedPath, `${videoId}.overlay.mp4`);
    const outPath = path.join(generatedPath, `${videoId}.mp4`);

    try {
      await withTimeout(
        exec(`${ffmpegPath} -y -f concat -safe 0 -i "${listPath}" -c copy "${tempConcat}"`),
        20000,
        "ffmpeg concat timed out"
      );
    } catch (e) {
      console.error("FFMPEG ERROR: concat step failed", e.stderr || e.message || e);
      return res.status(500).json({ error: "Video concat failed", detail: e.message });
    }

    // --- Step 4: Trim the video to finalDuration (ttsDuration + 2, min 15s) ---
    try {
      await withTimeout(
        exec(`${ffmpegPath} -y -i "${tempConcat}" -t ${finalDuration} -c copy "${tempTrimmed}"`),
        12000,
        "ffmpeg trim timed out"
      );
    } catch (e) {
      console.error("FFMPEG ERROR: trim step failed", e.stderr || e.message || e);
      return res.status(500).json({ error: "Video trim failed", detail: e.message });
    }

    // --- Step 5: Continue with overlay and mux as before, using tempTrimmed for the rest ---
    const overlayStart = (finalDuration * 0.75).toFixed(2);
    const overlayEnd = (ttsDuration + 1.5).toFixed(2); // Overlay until 1.5s after TTS ends
    const fadeInDur = 0.4;
    const fadeOutDur = 0.5;
    const fontfile = "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf";
    const safeOverlayText = String(overlayText)
      .toUpperCase()
      .replace(/[\n\r:"]/g, " ")
      .replace(/'/g, "")
      .replace(/[^A-Z0-9\s!]/g, "");

    let overlayCmd = fs.existsSync(fontfile)
      ? `${ffmpegPath} -y -i "${tempTrimmed}" -vf "drawtext=fontfile='${fontfile}':text='${safeOverlayText}':fontcolor=white:fontsize=44:box=0:shadowcolor=black:shadowx=3:shadowy=3:x=(w-text_w)/2:y=(h-text_h)/2:alpha='if(between(t,${overlayStart},${overlayStart}+${fadeInDur}),(t-${overlayStart})/${fadeInDur}, if(between(t,${overlayEnd}-${fadeOutDur},${overlayEnd}),(${overlayEnd}-t)/${fadeOutDur}, between(t,${overlayStart}+${fadeInDur},${overlayEnd}-${fadeOutDur})))'" -t ${overlayEnd} -c:v libx264 -crf 24 -preset superfast -pix_fmt yuv420p -an "${tempOverlay}"`
      : `${ffmpegPath} -y -i "${tempTrimmed}" -vf "drawtext=text='${safeOverlayText}':fontcolor=white:fontsize=44:box=0:shadowcolor=black:shadowx=3:shadowy=3:x=(w-text_w)/2:y=(h-text_h)/2:alpha='if(between(t,${overlayStart},${overlayStart}+${fadeInDur}),(t-${overlayStart})/${fadeInDur}, if(between(t,${overlayEnd}-${fadeOutDur},${overlayEnd}),(${overlayEnd}-t)/${fadeOutDur}, between(t,${overlayStart}+${fadeInDur},${overlayEnd}-${fadeOutDur})))'" -t ${overlayEnd} -c:v libx264 -crf 24 -preset superfast -pix_fmt yuv420p -an "${tempOverlay}"`;

    try {
      await withTimeout(exec(overlayCmd), 120000, "ffmpeg overlay timed out");
    } catch (e) {
      console.error("FFMPEG ERROR: text overlay failed", e.stderr || e.message || e);
      return res.status(500).json({ error: "Text overlay failed", detail: e.message });
    }

    // --- Mux audio with video as before ---
    try {
      await withTimeout(
        exec(`${ffmpegPath} -y -i "${tempOverlay}" -i "${ttsPath}" -map 0:v:0 -map 1:a:0 -shortest -c:v libx264 -preset superfast -crf 24 -c:a aac -b:a 192k "${outPath}"`),
        25000,
        "ffmpeg mux timed out"
      );
    } catch (e) {
      console.error("FFMPEG ERROR: mux step failed", e.stderr || e.message || e);
      return res.status(500).json({ error: "Final mux (video+audio) failed", detail: e.message });
    }

    // ----------- CRITICAL: Wait for output file -----------
    let videoReady = false;
    for (let i = 0; i < 30; i++) {
      try {
        const stats = fs.statSync(outPath);
        if (stats.size > 200000) { // >200KB = likely real video, not an empty file
          videoReady = true;
          break;
        }
      } catch {}
      await new Promise(res => setTimeout(res, 200));
    }
    if (!videoReady) {
      return res.status(500).json({ error: "Video output file not ready after mux" });
    }

    // Clean up temp files
    [tempConcat, tempTrimmed, tempOverlay, ...videoPaths, ttsPath, listPath].forEach(p => { try { fs.unlinkSync(p); } catch (e) {} });

    // Return public video URL and (optionally) upload to Ad Account
    const publicVideoUrl = `/generated/${videoId}.mp4`;
    const absoluteUrl = absolutePublicUrl(publicVideoUrl);

    let fbVideoId = null;
    try {
      // Read ad account from body, but get the token with a fallback to tokenStore
      const { fbAdAccountId } = req.body || {};
      const userAccessToken =
        (req.body && req.body.userAccessToken) || getFbUserToken();

      if (fbAdAccountId && userAccessToken) {
        const up = await uploadVideoToAdAccount(
          fbAdAccountId,
          userAccessToken,
          absoluteUrl,
          'SmartMark Generated Video',
          'Generated by SmartMark'
        );
        fbVideoId = up && up.id ? up.id : null;
        console.log('Uploaded to Ad Account. video_id:', fbVideoId);
      } else {
        console.log('Skipping FB advideos upload (missing fbAdAccountId or userAccessToken).');
      }
    } catch (e) {
      console.error('Ad Account video upload failed:', e?.response?.data || e.message);
    }

    return res.json({
      videoUrl: publicVideoUrl,
      absoluteVideoUrl: absoluteUrl,
      fbVideoId,
      video: { url: publicVideoUrl, script, overlayText, voice: TTS_VOICE },
      script,
      overlayText,
      voice: TTS_VOICE
    });
  } catch (err) {
    // Always send valid JSON even on crash
    console.error("Video route error:", err);
    if (!res.headersSent) {
      return res.status(500).json({
        error: "Failed to generate video ad",
        detail: (err && err.message) || "Unknown error"
      });
    }
  }
});

module.exports = router;
