// [server/routes/ai.js]
'use strict';

const express = require('express');
const router = express.Router();

/* ------------------------ CORS ------------------------ */
const ALLOW_ORIGINS = new Set([
  'http://localhost:3000',
  'http://127.0.0.1:3000',
  'https://smartmark-mvp.vercel.app',
  process.env.FRONTEND_ORIGIN,
].filter(Boolean));

router.use((req, res, next) => {
  const origin = req.headers.origin;
  if (origin && ALLOW_ORIGINS.has(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }
  res.setHeader('Vary', 'Origin');
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With, X-FB-AD-ACCOUNT-ID, X-SM-SID');
  res.setHeader('Access-Control-Max-Age', '86400');
  if (req.method === 'OPTIONS') return res.sendStatus(204);
  next();
});

/* ------------- Security & Rate-Limiting ------------- */
const { secureHeaders, basicRateLimit } = require('../middleware/security');
router.use(secureHeaders());
router.use(basicRateLimit({ windowMs: 15 * 60 * 1000, max: 120 }));
const heavyLimiter = basicRateLimit({ windowMs: 60 * 60 * 1000, max: 20 });

/* ------------------------------ Deps ------------------------------ */
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const sharp = require('sharp');
sharp.cache({ files: 0, items: 64, memory: 20 });
sharp.concurrency(1);

const { v4: uuidv4 } = require('uuid');
const FormData = require('form-data');
const { spawn } = require('child_process');
const seedrandom = require('seedrandom');
const { OpenAI } = require('openai');
const { getFbUserToken } = require('../tokenStore');
const db = require('../db');

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const PEXELS_API_KEY = process.env.PEXELS_API_KEY || '';

/* --------------------------- Helpers --------------------------- */
function publicBase() {
  return process.env.PUBLIC_BASE_URL || process.env.RENDER_EXTERNAL_URL || 'https://smartmark-mvp.onrender.com';
}
function absolutePublicUrl(relativePath) {
  if (!relativePath) return '';
  if (/^https?:\/\//i.test(relativePath)) return relativePath;
  return `${publicBase()}${relativePath}`;
}
function getUserToken(req) {
  const auth = req?.headers?.authorization || '';
  if (auth.startsWith('Bearer ')) return auth.slice(7).trim();
  if (req?.session?.fbUserAccessToken) return req.session.fbUserAccessToken;
  if (req?.body?.userAccessToken) return req.body.userAccessToken;
  return getFbUserToken() || null;
}
async function uploadVideoToAdAccount(adAccountId, userAccessToken, fileUrl, name = 'SmartMark Video', description = 'Generated by SmartMark') {
  const id = String(adAccountId || '').replace(/^act_/, '').replace(/\D/g, '');
  const url = `https://graph.facebook.com/v23.0/act_${id}/advideos`;
  const form = new FormData();
  form.append('file_url', fileUrl);
  form.append('name', name);
  form.append('description', description);
  const resp = await axios.post(url, form, { headers: form.getHeaders(), params: { access_token: userAccessToken } });
  return resp.data;
}

/* --------------------- Writable media dir & streamer --------------------- */
function ensureGeneratedDir() {
  const outDir = '/tmp/generated';
  try { fs.mkdirSync(outDir, { recursive: true }); } catch {}
  return outDir;
}

// Range-enabled streamer
router.get('/media/:file', async (req, res) => {
  try {
    const file = String(req.params.file || '').replace(/[^a-zA-Z0-9._-]/g, '');
    const full = path.join(ensureGeneratedDir(), file);
    if (!fs.existsSync(full)) return res.status(404).end();

    const stat = fs.statSync(full);
    const ext = path.extname(full).toLowerCase();
    const type = ext === '.mp4' ? 'video/mp4'
               : ext === '.jpg' || ext === '.jpeg' ? 'image/jpeg'
               : ext === '.png' ? 'image/png'
               : 'application/octet-stream';

    res.setHeader('Content-Type', type);
    res.setHeader('Accept-Ranges', 'bytes');
    res.setHeader('Access-Control-Expose-Headers', 'Content-Range');
    res.setHeader('Cross-Origin-Resource-Policy', 'cross-origin');
    res.setHeader('Cache-Control', 'public, max-age=86400, immutable');

    const range = req.headers.range;
    if (range) {
      const m = /bytes=(\d+)-(\d*)/.exec(range);
      const start = m ? parseInt(m[1], 10) : 0;
      const end = m && m[2] ? parseInt(m[2], 10) : stat.size - 1;
      if (start >= stat.size) return res.status(416).set('Content-Range', `bytes */${stat.size}`).end();
      res.status(206);
      res.setHeader('Content-Range', `bytes ${start}-${end}/${stat.size}`);
      res.setHeader('Content-Length', end - start + 1);
      fs.createReadStream(full, { start, end }).pipe(res);
    } else {
      res.setHeader('Content-Length', stat.size);
      fs.createReadStream(full).pipe(res);
    }
  } catch {
    res.status(500).end();
  }
});

function mediaPath(relativeFilename) {
  return `/api/media/${relativeFilename}`;
}
function maybeGC() { if (global.gc) { try { global.gc(); } catch {} } }

/* ---------- Persist generated assets (24h TTL) ---------- */
const ASSET_TTL_MS = Number(process.env.ASSET_TTL_MS || 24 * 60 * 60 * 1000);

function ownerKeyFromReq(req) {
  const cookieSid = req?.cookies?.sm_sid;
  const headerSid = req?.headers?.['x-sm-sid'];
  const auth = req?.headers?.authorization || '';
  const bearer = auth.startsWith('Bearer ') ? auth.slice(7).trim() : null;
  return cookieSid || headerSid || bearer || `ip:${req.ip}`;
}

async function ensureAssetsTable() {
  await db.read();
  db.data = db.data || {};
  db.data.generated_assets = db.data.generated_assets || [];
  await db.write();
}
async function purgeExpiredAssets() {
  await ensureAssetsTable();
  const now = Date.now();
  const before = db.data.generated_assets.length;
  db.data.generated_assets = db.data.generated_assets.filter(a => (a.expiresAt || 0) > now);
  if (db.data.generated_assets.length !== before) await db.write();
}
async function saveAsset({ req, kind, url, absoluteUrl, meta = {} }) {
  await ensureAssetsTable();
  await purgeExpiredAssets();

  const owner = ownerKeyFromReq(req);
  const now = Date.now();
  const rec = {
    id: uuidv4(),
    owner,
    kind,
    url,
    absoluteUrl,
    meta,
    createdAt: now,
    expiresAt: now + ASSET_TTL_MS
  };
  db.data.generated_assets.push(rec);

  const mine = db.data.generated_assets.filter(a => a.owner === owner).sort((a, b) => b.createdAt - a.createdAt);
  if (mine.length > 50) {
    const keepIds = new Set(mine.slice(0, 50).map(a => a.id));
    db.data.generated_assets = db.data.generated_assets.filter(a => a.owner !== owner || keepIds.has(a.id));
  }
  await db.write();
  return rec;
}
async function getRecentImageForOwner(req) {
  await purgeExpiredAssets();
  const owner = ownerKeyFromReq(req);
  const img = (db.data.generated_assets || [])
    .filter(a => a.owner === owner && a.kind === 'image')
    .sort((a,b)=>b.createdAt-a.createdAt)[0];
  return img ? (img.absoluteUrl || absolutePublicUrl(img.url)) : null;
}

/* ---------- Topic/category helpers ---------- */
const IMAGE_KEYWORD_MAP = [
  { match: ['protein','supplement','muscle','fitness','gym','workout'], keyword: 'gym workout' },
  { match: ['clothing','fashion','apparel','accessory','athleisure'], keyword: 'fashion model' },
  { match: ['makeup','cosmetic','skincare'], keyword: 'makeup application' },
  { match: ['hair','shampoo','conditioner','styling'], keyword: 'hair care' },
  { match: ['food','pizza','burger','meal','snack','kitchen'], keyword: 'delicious food' },
  { match: ['baby','kids','toys'], keyword: 'happy children' },
  { match: ['pet','dog','cat'], keyword: 'pet dog cat' },
  { match: ['electronics','phone','laptop','tech','gadget'], keyword: 'tech gadgets' },
  { match: ['home','decor','furniture','bedroom','bath'], keyword: 'modern home' },
  { match: ['art','painting','craft'], keyword: 'painting art' },
  { match: ['coffee','cafe','espresso'], keyword: 'coffee shop' },
];
function getImageKeyword(industry = '', url = '') {
  const input = `${industry} ${url}`.toLowerCase();
  for (const row of IMAGE_KEYWORD_MAP) if (row.match.some(m => input.includes(m))) return row.keyword;
  return industry || 'ecommerce';
}
function deriveTopicKeywords(answers = {}, url = '', fallback = 'shopping') {
  const industry = answers.industry || answers.productType || '';
  const base = getImageKeyword(industry, url) || industry || fallback;
  const extra = String(answers.description || answers.product || answers.mainBenefit || '').toLowerCase();
  if (extra.includes('coffee')) return 'coffee shop';
  if (/(protein|fitness|gym|workout|trainer)/.test(extra)) return 'gym workout';
  if (/(makeup|skincare|cosmetic)/.test(extra)) return 'makeup application';
  if (/hair/.test(extra)) return 'hair care';
  if (/(pet|dog|cat)/.test(extra)) return 'pet dog cat';
  if (/(electronics|phone|laptop)/.test(extra)) return 'tech gadgets';
  return base || fallback;
}

/* ---- Category detection & guardrails ---- */
function resolveCategory(answers = {}) {
  const txt = `${answers.industry || ''} ${answers.productType || ''} ${answers.description || ''}`.toLowerCase();
  if (/fashion|apparel|clothing|athleisure|outfit|wardrobe/.test(txt)) return 'fashion';
  if (/fitness|gym|workout|trainer|supplement|protein|yoga|crossfit|wellness/.test(txt)) return 'fitness';
  if (/makeup|cosmetic|skincare|beauty|serum|lipstick|foundation/.test(txt)) return 'cosmetics';
  if (/hair|shampoo|conditioner|styling/.test(txt)) return 'hair';
  if (/food|snack|meal|restaurant|pizza|burger|drink|beverage|kitchen/.test(txt)) return 'food';
  if (/pet|dog|cat|petcare|treats/.test(txt)) return 'pets';
  if (/electronics|phone|laptop|tech|gadget|device|camera/.test(txt)) return 'electronics';
  if (/home|decor|kitchen|furniture|bedroom|bath/.test(txt)) return 'home';
  if (/coffee|café|espresso|latte|roast/.test(txt)) return 'coffee';
  return 'generic';
}
const FASHION_TERMS = /\b(style|styles|outfit|outfits|wardrobe|pieces|fits?|colors?|sizes?)\b/gi;
function stripFashionIfNotApplicable(text, category) {
  if (category === 'fashion') return String(text || '');
  return String(text || '').replace(FASHION_TERMS, () => 'options');
}
function enforceCategoryPresence(text, category) {
  const t = String(text || '');
  const hasAny = (arr) => arr.some(w => new RegExp(`\\b${w}\\b`, 'i').test(t));
  const APPEND = (line) => (t.replace(/\s+/g, ' ').trim().replace(/[.]*\s*$/, '') + '. ' + line).trim();

  const req = {
    fitness: ['workout','training','gym','strength','wellness'],
    cosmetics: ['skin','makeup','beauty','serum','routine'],
    hair: ['hair','shampoo','conditioner','styling'],
    food: ['fresh','flavor','taste','meal','snack'],
    pets: ['pet','dog','cat','treat'],
    electronics: ['tech','device','gadget','performance'],
    home: ['home','kitchen','decor','space'],
    coffee: ['coffee','brew','roast','espresso'],
    fashion: ['style','outfit','fabric','fit'],
    generic: []
  }[category] || [];

  if (!req.length || hasAny(req)) return t;
  const injection = {
    fitness: 'Designed for your workout and training.',
    cosmetics: 'Made to fit into your beauty routine.',
    hair: 'Helps you care for and style your hair.',
    food: 'Made for great taste and an easy experience.',
    pets: 'Made for everyday pet care with less hassle.',
    electronics: 'Built for reliable performance.',
    home: 'A simple way to upgrade your space.',
    coffee: 'Balanced flavor for a better coffee break.',
    fashion: 'Find a look that works for you.',
    generic: 'Easy to use and simple to get started.'
  }[category];
  return APPEND(injection);
}
function cleanFinalText(text) {
  return String(text || '')
    .replace(/\s+/g, ' ')
    .replace(/\.{2,}/g, '.')
    .replace(/\s([.!,?])/g, '$1')
    .replace(/(?:https?:\/\/)?(?:www\.)?[a-z0-9\-]+\.[a-z]{2,}(?:\/\S*)?/gi, '')
    .replace(/\b(dot|com|net|org|io|co)\b/gi, '')
    .trim();
}

/* ---------- Overlay headline helpers ---------- */
function categoryLabelForOverlay(category) {
  return {
    fashion: 'FASHION',
    fitness: 'TRAINING',
    cosmetics: 'BEAUTY',
    hair: 'HAIR CARE',
    food: 'FOOD',
    pets: 'PET CARE',
    electronics: 'TECH',
    home: 'HOME',
    coffee: 'COFFEE',
    generic: 'SHOP'
  }[category || 'generic'];
}
function overlayTitleFromAnswers(answers = {}, categoryOrTopic = '') {
  const category = categoryOrTopic && /^(fashion|fitness|cosmetics|hair|food|pets|electronics|home|coffee|generic)$/i.test(categoryOrTopic)
    ? categoryOrTopic.toLowerCase()
    : null;

  const brand = (answers.businessName || '').trim().toUpperCase();
  if (brand) {
    const label = category ? categoryLabelForOverlay(category) : 'SHOP';
    const words = brand.split(/\s+/);
    return (words.length === 1 ? `${brand} ${label}` : brand).slice(0, 30);
  }
  if (category) return categoryLabelForOverlay(category);
  return (String(categoryOrTopic || 'SHOP')).toUpperCase().slice(0, 24);
}

/* ------------------------ Training context ------------------------ */
const DATA_DIR = path.join(__dirname, '../data');
const ALLOWED_EXT = new Set(['.txt', '.md', '.markdown', '.json']);
const MAX_FILE_MB = 1.5;
const MAX_TOTAL_CHARS = 45_000;
function loadTrainingContext() {
  if (!fs.existsSync(DATA_DIR)) return '';
  const files = fs.readdirSync(DATA_DIR)
    .map(f => path.join(__dirname, '../data', f))
    .filter(full => {
      const ext = path.extname(full).toLowerCase();
      try {
        const st = fs.statSync(full);
        return st.isFile() && ALLOWED_EXT.has(ext) && st.size <= MAX_FILE_MB * 1024 * 1024;
      } catch { return false; }
    });
  let ctx = '';
  for (const f of files) {
    try {
      const ext = path.extname(f).toLowerCase();
      let text = fs.readFileSync(f, 'utf8');
      if (ext === '.json') { try { text = JSON.stringify(JSON.parse(text)); } catch {} }
      if (!text.trim()) continue;
      const block = `\n\n### SOURCE: ${path.basename(f)}\n${text}\n`;
      if (ctx.length + block.length <= MAX_TOTAL_CHARS) ctx += block;
    } catch {}
  }
  return ctx.trim();
}
let customContext = loadTrainingContext();

/* ---------------------------- Scrape ---------------------------- */
router.get('/test', (_req, res) => res.json({ msg: 'AI route is working!' }));

async function getWebsiteText(url) {
  try {
    const clean = String(url || '').trim();
    if (!clean || !/^https?:\/\//i.test(clean)) throw new Error('Invalid URL');
    const { data, headers } = await axios.get(clean, { timeout: 7000, maxRedirects: 3, validateStatus: s => s < 400 });
    if (!headers['content-type']?.includes('text/html')) throw new Error('Not HTML');
    const body = String(data)
      .replace(/<script[\s\S]*?<\/script>/gi, '')
      .replace(/<style[\s\S]*?<\/style>/gi, '')
      .replace(/<[^>]+>/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
    if (body.length < 200 || /cloudflare|access denied|429/i.test(body)) throw new Error('blocked/short');
    return body.slice(0, 3500);
  } catch {
    return '';
  }
}

/* --------------------------- Ad Copy --------------------------- */
router.post('/generate-ad-copy', async (req, res) => {
  const { description = '', businessName = '', url = '', answers = {} } = req.body;
  if (!description && !businessName && !url && !answers?.industry) {
    return res.status(400).json({ error: 'Please provide at least a description.' });
  }

  const category = resolveCategory(answers || {});
  const forbidFashionLine = category === 'fashion'
    ? ''
    : `- Do NOT mention clothing terms like styles, fits, colors, sizes, outfits, wardrobe.`;

  let prompt =
`You are an expert direct-response ad copywriter for e-commerce/online businesses.
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}Write only the exact words for a spoken video ad script (about 46–72 words ≈ 15–17 seconds).
- Keep it neutral and accurate; avoid assumptions about shipping, returns, guarantees, or inventory.
- Keep it specific to the industry/category: ${category}.
${forbidFashionLine}
- Hook → value → simple CTA (from: “Shop now”, “Buy now”, “Learn more”, “Visit us”, “Check us out”, “Take a look”, “Get started”).
- Do NOT mention a website or domain.
- Use the CTA phrase exactly once at the very end.
Output ONLY the script text.`;

  if (description) prompt += `\nBusiness Description: ${description}`;
  if (businessName) prompt += `\nBusiness Name: ${businessName}`;
  if (answers?.industry) prompt += `\nIndustry: ${answers.industry}`;
  if (url) prompt += `\nWebsite (for context only): ${url}`;

  try {
    const r = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 220,
      temperature: 0.35
    });
    let script = r.choices?.[0]?.message?.content?.trim() || '';
    script = stripFashionIfNotApplicable(script, category);
    script = enforceCategoryPresence(script, category);
    script = cleanFinalText(script);
    res.json({ adCopy: script });
  } catch {
    res.status(500).json({ error: 'Failed to generate ad copy' });
  }
});

/* ------------------- Campaign assets (headline/body/cta) ------------------- */
router.post('/generate-campaign-assets', async (req, res) => {
  try {
    const { answers = {}, url = '' } = req.body;
    const category = resolveCategory(answers || {});

    const brandFromUrl = (u = '') => {
      try {
        const h = new URL(u).hostname.replace(/^www\./, '');
        const base = h.split('.')[0] || 'Your Brand';
        return base.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
      } catch { return 'Your Brand'; }
    };
    const brand = (answers.businessName && String(answers.businessName).trim()) || brandFromUrl(url);
    const industry = (answers.industry && String(answers.industry).trim()) || '';
    const mainBenefit = (answers.mainBenefit && String(answers.mainBenefit).trim()) || '';
    const offer = (answers.offer && String(answers.offer).trim()) || '';

    let websiteText = '';
    try { if (url && /^https?:\/\//i.test(url)) websiteText = await getWebsiteText(url); } catch {}

    const forbidFashionLine = category === 'fashion'
      ? ''
      : `- Do NOT mention clothing terms like styles, fits, colors, sizes, outfits, wardrobe.`;

    const prompt = `
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}You are a senior direct-response copywriter for e-commerce.
Write JSON ONLY:

{
  "headline": "max 55 characters, plain and neutral (no assumptions)",
  "body": "18-30 words, friendly and value-focused, neutral claims only, no emojis/hashtags",
  "image_overlay_text": "4 words max, simple CTA in ALL CAPS"
}

Rules:
- Keep copy specific to the category: ${category}.
${forbidFashionLine}
- Never include a website or domain.
Context:
Brand: ${brand}
Industry: ${industry || '[general ecommerce]'}
Main benefit: ${mainBenefit || '[unspecified]'}
Offer: ${offer || '[none]'}
Website text (may be empty): """${(websiteText || '').slice(0, 1200)}"""`.trim();

    let headline = '', body = '', overlay = '';
    try {
      const r = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 220,
        temperature: 0.35
      });
      const raw = r.choices?.[0]?.message?.content?.trim() || '{}';
      const jsonStr = (raw.match(/\{[\s\S]*\}/) || [raw])[0];
      const parsed = JSON.parse(jsonStr);

      const clean = (s, max = 200) => cleanFinalText(String(s || '')).slice(0, max);
      headline = clean(parsed.headline, 55);
      body = stripFashionIfNotApplicable(clean(parsed.body, 220), category);
      overlay = clean(parsed.image_overlay_text, 28);
    } catch {
      headline = `${brand}: New Products`;
      body = `Explore useful products designed for daily use, with a focus on simplicity and value. See what works best for you.`;
      overlay = 'LEARN MORE';
    }

    headline = headline.replace(/["<>]/g, '').slice(0, 55);
    body = body.replace(/["<>]/g, '').trim();

    overlay = pickFromAllowedCTAs(answers).toUpperCase();

    return res.json({ headline, body, image_overlay_text: overlay });
  } catch {
    return res.json({
      headline: 'New Products Just In',
      body: 'Explore everyday products designed for simplicity and value. See what’s new and find what works for you.',
      image_overlay_text: 'LEARN MORE'
    });
  }
});

/* ---------------------- Image overlays (modern, tasteful) ---------------------- */
const PEXELS_IMG_BASE = 'https://api.pexels.com/v1/search';
function escSVG(s){return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;')}
function estWidth(text, fs){return (String(text||'').length||1)*fs*0.56}
function fitFont(text, maxW, startFs, minFs=26){let fs=startFs;while(fs>minFs&&estWidth(text,fs)>maxW)fs-=2;return fs}
function splitTwoLines(text,maxW,startFs){
  const words=String(text||'').split(/\s+/).filter(Boolean);
  if(words.length<=2)return{lines:[text],fs:fitFont(text,maxW,startFs)};
  for(let cut=Math.ceil(words.length/2);cut<words.length-1;cut++){
    const a=words.slice(0,cut).join(' '),b=words.slice(cut).join(' ');
    let fs=startFs;fs=Math.min(fitFont(a,maxW,fs),fitFont(b,maxW,fs));
    if(estWidth(a,fs)<=maxW && estWidth(b,fs)<=maxW) return {lines:[a,b],fs};
  }
  return {lines:[text],fs:fitFont(text,maxW,startFs)};
}
const BANNED_TERMS = /\b(unisex|global|vibes?|forward|finds?|chic|bespoke|avant|couture)\b/i;
function cleanHeadline(h){
  h=String(h||'').replace(/[^a-z0-9 &\-]/gi,' ').replace(/\s+/g,' ').trim();
  if(!h || BANNED_TERMS.test(h)) return '';
  const words=h.split(' ');
  if(words.length>6) h = words.slice(0,6).join(' ');
  return h.toUpperCase();
}

/* Allowed CTA list */
const ALLOWED_CTAS = [
  'SHOP NOW!', 'BUY NOW!', 'CHECK US OUT!', 'VISIT US!',
  'TAKE A LOOK!', 'LEARN MORE!', 'GET STARTED!'
];
function pickFromAllowedCTAs(answers = {}, seed = '') {
  const t = String(answers?.cta || '').trim();
  if (t) {
    const norm = t.toUpperCase().replace(/['’]/g,'').replace(/[^A-Z0-9 !?]/g,'').replace(/\s+/g,' ').trim();
    const withBang = /!$/.test(norm) ? norm : `${norm}!`;
    if (ALLOWED_CTAS.includes(withBang)) return withBang;
  }
  let h = 0; for (const c of String(seed || Date.now())) h = (h*31 + c.charCodeAt(0))>>>0;
  return ALLOWED_CTAS[h % ALLOWED_CTAS.length];
}
function cleanCTA(c){
  const norm = String(c||'').toUpperCase().replace(/['’]/g,'').replace(/[^A-Z0-9 !?]/g,'').replace(/\s+/g,' ').trim();
  const withBang = /!$/.test(norm) ? norm : (norm ? `${norm}!` : '');
  return ALLOWED_CTAS.includes(withBang) ? withBang : 'LEARN MORE!';
}

/* Modern fonts */
function pickSansFontFile() {
  const candidates = [
    '/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf',
    '/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf',
    '/usr/share/fonts/truetype/noto/NotoSans-Regular.ttf',
    '/usr/share/fonts/truetype/freefont/FreeSans.ttf',
    '/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf'
  ];
  for (const p of candidates) { try { if (fs.existsSync(p)) return p; } catch {} }
  return null;
}

/* Auto-placement analysis */
async function analyzeImageForPlacement(imgBuf) {
  try {
    const W = 72, H = 72;
    const { data } = await sharp(imgBuf).resize(W, H, { fit: 'cover' }).removeAlpha().raw().toBuffer({ resolveWithObject: true });
    let left=0,right=0,top=0,bottom=0, rSum=0,gSum=0,bSum=0;
    for (let y=0;y<H;y++){
      for (let x=0;x<W;x++){
        const i = (y*W + x)*3;
        const r = data[i], g = data[i+1], b = data[i+2];
        const l = 0.2126*r + 0.7152*g + 0.0722*b;
        if (x < W/2) left += l; else right += l;
        if (y < H/2) top += l; else bottom += l;
        rSum += r; gSum += g; bSum += b;
      }
    }
    const darkerSide = (left<right) ? 'left' : 'right';
    const darkerBand = (top<bottom) ? 'top' : 'bottom';
    const avg = { r:Math.round(rSum/(W*H)), g:Math.round(gSum/(W*H)), b:Math.round(bSum/(W*H)) };
    // choose accent from palette
    const palette = ['#E63946','#2B6CB0','#2F855A','#6B46C1'];
    const brandColor = palette[(avg.b>avg.r?1:0) + (avg.g>avg.b?2:0)] || '#E63946';
    const diffLR = Math.abs(left-right) / (W*H);
    return { darkerSide, darkerBand, brandColor, diffLR };
  } catch { return { darkerSide:'left', darkerBand:'top', brandColor:'#E63946', diffLR: 0.0 }; }
}

/* SVG overlays (semi-transparent, tasteful) */
function svgOverlay({ W, H, headline, cta, tpl = 2, prefer='left', preferBand='top', brandColor='#E63946', strength=0.88 }) {
  const LIGHT = '#f5f7f9';
  const MAX_W = W - 120;
  const pill = (x, y, text, fs = 28) => {
    fs = Math.max(22, Math.min(fs, 34));
    const w = Math.min(MAX_W, estWidth(text, fs) + 50);
    const h = 50;
    const x0 = x - w / 2;
    return `
      <g transform="translate(${x0}, ${y - Math.floor(h * 0.6)})">
        <rect x="0" y="-14" width="${w}" height="${h}" rx="24" fill="#0b0d10d0"/>
        <text x="${w / 2}" y="12" text-anchor="middle"
              font-family="Inter, Helvetica, Arial, DejaVu Sans, sans-serif"
              font-size="${fs}" font-weight="800" fill="#ffffff" letter-spacing="0.8">
          ${escSVG(text)}
        </text>
      </g>`;
  };

  // Semi-transparent side panel (like pro ads) — smaller width to avoid “half split”
  if (tpl === 5) {
    const panelW = 440;
    const pad = 34;
    const x0 = prefer === 'left' ? 24 : W - panelW - 24;
    const cx = x0 + pad;
    const textW = panelW - pad*2;
    const fit = splitTwoLines(headline, textW, 56);
    const yTitle = 128;
    const yCTA = yTitle + fit.fs * (fit.lines.length) + 60;
    return `
      <defs>
        <linearGradient id="panelShade" x1="0" y1="0" x2="${prefer==='left'?1:0}" y2="0">
          <stop offset="0%" stop-color="${brandColor}" stop-opacity="${strength}"/>
          <stop offset="100%" stop-color="${brandColor}" stop-opacity="${Math.max(0,strength-0.28)}"/>
        </linearGradient>
        <pattern id="dots" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
          <circle cx="2.5" cy="2.5" r="1.7" fill="#ffffff22"/>
        </pattern>
      </defs>
      <rect x="${x0}" y="24" width="${panelW}" height="${H-48}" rx="28" fill="url(#panelShade)" />
      <rect x="${x0}" y="24" width="${panelW}" height="${H-48}" rx="28" fill="url(#dots)"/>
      <text x="${cx}" y="${yTitle}" text-anchor="start"
            font-family="Inter, Helvetica, Arial, DejaVu Sans, sans-serif"
            font-size="${fit.fs}" font-weight="900" fill="#ffffff" letter-spacing="1.1">
        <tspan x="${cx}" dy="0">${escSVG(fit.lines[0])}</tspan>
        ${fit.lines[1] ? `<tspan x="${cx}" dy="${fit.fs * 1.05}">${escSVG(fit.lines[1])}</tspan>` : ''}
      </text>
      ${pill(cx + 130, yCTA, cta, 28)}
    `;
  }

  if (tpl === 2) {
    const fs = fitFont(headline, MAX_W - 80, 56);
    const yTitle = 96;
    const yCTA = yTitle + 68;
    return `
      <defs>
        <linearGradient id="g2" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="#000C"/>
          <stop offset="100%" stop-color="#0000"/>
        </linearGradient>
      </defs>
      <rect x="0" y="0" width="${W}" height="190" rx="18" fill="url(#g2)"/>
      <text x="${W / 2}" y="${yTitle}" text-anchor="middle"
            font-family="Inter, Helvetica, Arial, DejaVu Sans, sans-serif"
            font-size="${fs}" font-weight="800" fill="${LIGHT}" letter-spacing="1.4">
        ${escSVG(headline)}
      </text>
      ${pill(W / 2, yCTA, cta, 28)}
    `;
  }

  if (tpl === 3) {
    const boxW = 820;
    const fit = splitTwoLines(headline, boxW - 100, 54);
    const lineCount = fit.lines.length;
    const boxPad = 26;
    const gap = 16;
    const boxH = Math.round(boxPad * 2 + fit.fs * lineCount + 54 + gap);
    const yBox = Math.round((H - boxH) / 2);
    const yTitle = yBox + boxPad + fit.fs - 6;
    const yCTA = yBox + boxH - boxPad - 12;

    return `
      <rect x="${(W - boxW) / 2}" y="${yBox}" width="${boxW}" height="${boxH}" rx="26" fill="#00000045" />
      <text x="${W / 2}" y="${yTitle}" text-anchor="middle"
            font-family="Inter, Helvetica, Arial, DejaVu Sans, sans-serif"
            font-size="${fit.fs}" font-weight="800" fill="#f2f5f6" letter-spacing="1.2">
        <tspan x="${W / 2}" dy="0">${escSVG(fit.lines[0])}</tspan>
        ${fit.lines[1] ? `<tspan x="${W / 2}" dy="${fit.fs * 1.05}">${escSVG(fit.lines[1])}</tspan>` : ''}
      </text>
      ${pill(W / 2, yCTA, cta, 28)}
    `;
  }

  if (tpl === 4) {
    const padX = 64, padY = 110, panelW = 520;
    const fit = splitTwoLines(headline, panelW - 2 * padX, 52);
    const yBase = preferBand === 'top' ? padY : H - padY - fit.fs * (fit.lines.length);
    const yCTA = yBase + fit.fs * 1.05 * (fit.lines.length) + 58;

    return `
      <defs>
        <linearGradient id="gL" x1="${prefer==='left'?0:1}" y1="0" x2="${prefer==='left'?1:0}" y2="0">
          <stop offset="0%" stop-color="#000a"/>
          <stop offset="100%" stop-color="#0000"/>
        </linearGradient>
      </defs>
      <rect x="${prefer==='left'?0:W-panelW}" y="0" width="${panelW}" height="${H}" fill="url(#gL)"/>
      <text x="${prefer==='left'?padX:W-panelW+padX}" y="${yBase}" text-anchor="start"
            font-family="Inter, Helvetica, Arial, DejaVu Sans, sans-serif"
            font-size="${fit.fs}" font-weight="800" fill="#f2f5f6" letter-spacing="1.2">
        <tspan x="${prefer==='left'?padX:W-panelW+padX}" dy="0">${escSVG(fit.lines[0])}</tspan>
        ${fit.lines[1] ? `<tspan x="${prefer==='left'?padX:W-panelW+padX}" dy="${fit.fs * 1.05}">${escSVG(fit.lines[1])}</tspan>` : ''}
      </text>
      ${pill((prefer==='left'?padX:W-panelW+padX) + 140, yCTA, cta, 26)}
    `;
  }

  return svgOverlay({ W, H, headline, cta, tpl: 4, prefer, preferBand, brandColor });
}

/* Build overlaid JPG */
async function buildOverlayImage({ imageUrl, headlineHint = '', ctaHint = '', seed = '', fallbackHeadline = 'SHOP' }) {
  const W = 1200, H = 627;
  const imgRes = await axios.get(imageUrl, { responseType: 'arraybuffer', timeout: 8000 });
  const analysis = await analyzeImageForPlacement(imgRes.data);

  const base = sharp(imgRes.data).resize(W, H, { fit: 'cover' });
  const headline = cleanHeadline(headlineHint) || cleanHeadline(fallbackHeadline) || 'SHOP';
  const cta = cleanCTA(ctaHint) || 'LEARN MORE!';

  let h = 0; for (const c of String(seed || Date.now())) h = (h * 31 + c.charCodeAt(0)) >>> 0;
  // If left/right luminance is very similar, prefer a top band layout (tpl 2/3)
  const tplPool = analysis.diffLR > 40 ? [5, 4, 2] : [2, 3, 5, 4];
  const tpl = tplPool[h % tplPool.length];

  const overlaySVG = Buffer.from(
    `<svg width="${W}" height="${H}" xmlns="http://www.w3.org/2000/svg">${svgOverlay({
      W, H, headline, cta, tpl,
      prefer: analysis.darkerSide,
      preferBand: analysis.darkerBand,
      brandColor: analysis.brandColor,
      strength: 0.86
    })}</svg>`
  );

  const outDir = ensureGeneratedDir();
  const file = `${uuidv4()}.jpg`;
  await base.composite([{ input: overlaySVG, top: 0, left: 0 }]).jpeg({ quality: 92 }).toFile(path.join(outDir, file));
  maybeGC();

  return { publicUrl: mediaPath(file), absoluteUrl: absolutePublicUrl(mediaPath(file)), filename: file };
}

/* ------------------------------ Music ------------------------------ */
function findMusicDir() {
  const candidates = [
    path.join(__dirname, '..', 'Music', 'music'),
    path.join(__dirname, '..', 'music', 'music'),
    path.join(__dirname, '..', 'Music'),
    path.join(__dirname, '..', 'music')
  ];
  for (const p of candidates) { try { if (fs.existsSync(p) && fs.statSync(p).isDirectory()) return p; } catch {} }
  return null;
}
function pickMusicFile(keywords = []) {
  const base = findMusicDir();
  if (!base) return null;
  const files = fs.readdirSync(base).filter(f => /\.mp3$/i.test(f));
  if (!files.length) return null;
  const lower = files.map(f => f.toLowerCase());
  for (const kw of keywords.map(x => String(x).toLowerCase())) {
    let i = lower.findIndex(f => f === `${kw}.mp3`); if (i !== -1) return path.join(base, files[i]);
    i = lower.findIndex(f => f.includes(kw)); if (i !== -1) return path.join(base, files[i]);
  }
  return path.join(base, files[0]);
}

/* ------------------------------- Utils ------------------------------- */
async function downloadFileWithTimeout(url, dest, timeoutMs=14000, maxSizeMB=6) {
  return new Promise((resolve, reject) => {
    if (!url || !/^https?:\/\//i.test(String(url))) return reject(new Error('Invalid clip URL'));
    const writer = fs.createWriteStream(dest);
    let timedOut = false;
    const timeout = setTimeout(()=>{timedOut=true;writer.destroy();try{fs.unlinkSync(dest);}catch{};reject(new Error('Download timed out'));}, timeoutMs);
    axios({ url, method:'GET', responseType:'stream', timeout: timeoutMs })
      .then(resp => {
        let bytes=0;
        resp.data.on('data', ch => { bytes+=ch.length; if (bytes > maxSizeMB*1024*1024 && !timedOut) { timedOut=true; writer.destroy(); try{fs.unlinkSync(dest);}catch{}; clearTimeout(timeout); reject(new Error('File too large')); }});
        resp.data.on('error', err => { clearTimeout(timeout); if (!timedOut) reject(err); });
        resp.data.pipe(writer);
        writer.on('finish', ()=>{clearTimeout(timeout); if (!timedOut) resolve(dest);});
        writer.on('error', err=>{clearTimeout(timeout); try{fs.unlinkSync(dest);}catch{}; if (!timedOut) reject(err);});
      })
      .catch(err=>{clearTimeout(timeout); try{fs.unlinkSync(dest);}catch{}; reject(err);});
  });
}
function getDeterministicShuffle(arr, seed) {
  const rng = seedrandom(String(seed || Date.now()));
  const a = [...arr];
  for (let i=a.length-1;i>0;i--){const j=Math.floor(rng()*(i+1));[a[i],a[j]]=[a[j],a[i]];}
  return a;
}
function safeFFText(t){
  return String(t||'')
    .replace(/['’]/g,'')                 // kill apostrophes to avoid drawtext parse issues
    .replace(/[\n\r]/g,' ')
    .replace(/[:]/g,' ')
    .replace(/[\\"]/g,'')
    .replace(/(?:https?:\/\/)?(?:www\.)?[a-z0-9\-]+\.[a-z]{2,}(?:\/\S*)?/gi,'')
    .replace(/\b(dot|com|net|org|io|co)\b/gi, '')
    .replace(/[^A-Za-z0-9 !?\-]/g,' ')
    .replace(/\s+/g,' ')
    .trim()
    .toUpperCase()
    .slice(0, 40);
}

/* ---- CTA helpers ---- */
function chooseCTA(answers={}, seed='') { return pickFromAllowedCTAs(answers, seed); }
function finalizeScriptWithSingleCTA(text, chosenCTA) {
  const plainList = ['SHOP NOW','BUY NOW','CHECK US OUT','VISIT US','TAKE A LOOK','LEARN MORE','GET STARTED'];
  const plain = plainList.map(s => s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')).join('|');
  const re = new RegExp(`\\b(?:${plain})\\b[.!?]*`, 'gi');
  let cleaned = String(text || '').replace(re, '').replace(/\s+/g,' ').trim();
  cleaned = cleaned.replace(/\.{2,}/g, '.');
  if (!/[.!?]$/.test(cleaned)) cleaned += '.';
  cleaned += ' ' + chosenCTA;
  return cleaned.replace(/\s+/g,' ').trim();
}

/* ---- Subtitles via textfiles (robust) ---- */
function splitForCaptions(text) {
  let parts = String(text||'').trim().replace(/\s+/g,' ')
    .split(/(?<=[.?!])\s+/).filter(Boolean);
  if (parts.length < 3) {
    const more = String(text).split(/,\s+/).filter(s=>s.length>12);
    parts = parts.concat(more).slice(0,5);
  }
  if (parts.length > 5) {
    const merged = [];
    for (const p of parts){
      if (!merged.length) merged.push(p);
      else if (merged[merged.length-1].length < 40) merged[merged.length-1] += ' ' + p;
      else merged.push(p);
      if (merged.length === 5) break;
    }
    parts = merged;
  }
  return parts.map(p => p.trim().replace(/\s+/g,' ')).filter(Boolean);
}
function buildCaptionDrawtexts(script, duration, fontParam, workId='w') {
  const outDir = ensureGeneratedDir();
  const files = [];
  const WINDOW_START = 0.35;
  const TAIL = 0.80;
  const endWindow = Math.max(WINDOW_START + 1.2, duration - TAIL);
  const total = Math.max(1.2, endWindow - WINDOW_START);
  const segs = splitForCaptions(script);
  if (!segs.length) return { filter:'', files:[] };

  const lens = segs.map(s=>Math.max(12, Math.min(90, s.length)));
  const sum = lens.reduce((a,b)=>a+b,0);
  let t = WINDOW_START;
  const pieces = [];
  const baseStyle = "fontcolor=white@0.98:borderw=2:bordercolor=black@0.85:shadowx=1:shadowy=1:shadowcolor=black@0.7:box=1:boxcolor=0x000000@0.50:boxborderw=28:fontsize=24:x='(w-tw)/2':y='h*0.83'";

  for (let i=0;i<segs.length;i++){
    const dur = Math.max(1.2, (lens[i]/sum)*total);
    const start = t;
    const stop = Math.min(endWindow, t + dur);
    t = stop + 0.05;

    const tf = path.join(outDir, `cap_${workId}_${i}.txt`);
    try { fs.writeFileSync(tf, segs[i]); files.push(tf); } catch {}
    pieces.push(`drawtext=${fontParam}textfile='${tf}':${baseStyle}:enable='between(t,${start.toFixed(2)},${stop.toFixed(2)})'`);
    if (t >= endWindow) break;
  }
  return { filter: pieces.join(','), files };
}

/* -------------------------- Spawned processes -------------------------- */
function runSpawn(cmd, args, opts = {}) {
  return new Promise((resolve, reject) => {
    const child = spawn(cmd, args, { stdio: ['ignore', 'ignore', 'inherit'], ...opts });
    let killed = false;
    const killTimer = opts.killAfter ? setTimeout(() => {
      killed = true;
      try { child.kill('SIGKILL'); } catch {}
      reject(new Error(opts.killMsg || 'process timeout'));
    }, opts.killAfter) : null;

    child.on('error', err => { if (killTimer) clearTimeout(killTimer); reject(err); });
    child.on('close', code => {
      if (killTimer) clearTimeout(killTimer);
      if (killed) return;
      code === 0 ? resolve() : reject(new Error(`${cmd} exited with code ${code}`));
    });
  });
}
async function probeDuration(file, timeoutMs=8000) {
  return new Promise((resolve) => {
    const child = spawn('ffprobe', ['-v', 'error', '-show_entries', 'format=duration', '-of', 'default=nokey=1:noprint_wrappers=1', file], { stdio: ['ignore', 'pipe', 'ignore'] });
    let out = '';
    const timer = setTimeout(()=>{ try { child.kill('SIGKILL'); } catch {}; resolve(0); }, timeoutMs);
    child.stdout.on('data', d => { if (out.length < 64) out += d.toString('utf8'); });
    child.on('close', () => { clearTimeout(timer); const s = parseFloat(out.trim()); resolve(isNaN(s)?0:s); });
    child.on('error', () => { clearTimeout(timer); resolve(0); });
  });
}
function pickSerifFontFile() {
  const candidates = [
    '/usr/share/fonts/truetype/msttcorefonts/Times_New_Roman.ttf',
    '/usr/share/fonts/truetype/msttcorefonts/Times_New_Roman_Bold.ttf',
    '/usr/share/fonts/truetype/msttcorefonts/times.ttf',
    '/usr/share/fonts/truetype/freefont/FreeSerif.ttf',
    '/usr/share/fonts/truetype/noto/NotoSerif-Regular.ttf',
    '/usr/share/fonts/truetype/dejavu/DejaVuSerif-Bold.ttf',
    '/usr/share/fonts/truetype/dejavu/DejaVuSerif.ttf'
  ];
  for (const p of candidates) { try { if (fs.existsSync(p)) return p; } catch {} }
  return null;
}

/* -------------------- Still video (modern + captions) -------------------- */
async function composeStillVideo({ imageUrl, duration, ttsPath = null, musicPath = null, brandLine = 'YOUR BRAND!', ctaText = 'LEARN MORE!', scriptText = '' }) {
  const outDir = ensureGeneratedDir();
  const id = uuidv4();
  const outFile = `${id}.mp4`;
  const outPath = path.join(outDir, outFile);

  // robust fallback image
  let finalImageUrl = imageUrl || 'https://picsum.photos/seed/smartmark/1200/1200';
  try { await axios.get(finalImageUrl, { timeout: 5000 }); } catch { finalImageUrl = 'https://singlecolorimage.com/get/2b2f33/1200x1200'; }

  let imgFile = null;
  try {
    imgFile = path.join(outDir, `${id}.jpg`);
    const imgRes = await axios.get(finalImageUrl, { responseType: 'arraybuffer', timeout: 7000 });
    fs.writeFileSync(imgFile, imgRes.data);
  } catch { imgFile = null; }

  const sansFile = pickSansFontFile();
  const serifFile = pickSerifFontFile();
  const fontParamSans = sansFile ? `fontfile='${sansFile}':` : `font='Arial':`;
  const fontParamSerif = serifFile ? `fontfile='${serifFile}':` : `font='Times New Roman':`;
  const txtCommon = `fontcolor=white@0.99:borderw=2:bordercolor=black@0.88:shadowx=1:shadowy=1:shadowcolor=black@0.75`;

  const brand = safeFFText(brandLine);
  const cta   = safeFFText(ctaText);

  const TAIL = 0.8;

  const args = ['-y'];
  if (imgFile) {
    args.push('-loop', '1', '-t', duration.toFixed(2), '-i', imgFile);
  } else {
    args.push('-f', 'lavfi', '-t', duration.toFixed(2), '-i', 'color=c=0x101318:s=640x640');
  }

  const inputs = [];
  if (ttsPath) { args.push('-i', ttsPath); inputs.push('tts'); }
  if (musicPath) { args.push('-i', musicPath); inputs.push('music'); }
  if (!ttsPath && !musicPath) {
    args.push('-f', 'lavfi', '-t', duration.toFixed(2), '-i', 'anullsrc=channel_layout=stereo:sample_rate=44100');
    inputs.push('silence');
  }

  // contain + pad + gentle zoom
  const baseVideo = imgFile
    ? `[0:v]scale='if(gte(iw/ih,1),640,-2)':'if(gte(iw/ih,1),-2,640)',` +
      `pad=640:640:(640-iw)/2:(640-ih)/2,setsar=1,format=yuv420p,zoompan=z='min(zoom+0.00035,1.03)':` +
      `d=${Math.floor(24*duration)}:x='(iw-iw/zoom)/2':y='(ih-ih/zoom)/2',fps=24[cv]`
    : `[0:v]fps=24,format=yuv420p[cv]`;

  const brandIntro = `drawtext=${fontParamSans}text='${brand}':${txtCommon}:fontsize=30:x='(w-tw)/2':y='h*0.12':enable='between(t,0.2,3.1)'`;
  const ctaOutro   = `drawtext=${fontParamSans}text='${cta}':${txtCommon}:box=1:boxcolor=0x0b0d10@0.82:boxborderw=20:fontsize=44:x='(w-tw)/2':y='(h/2-16)':enable='gte(t,${(duration-TAIL).toFixed(2)})'`;

  const subsBuild = buildCaptionDrawtexts(scriptText, duration, fontParamSerif, id);
  let fc = `${baseVideo};[cv]${brandIntro}${subsBuild.filter?','+subsBuild.filter:''},${ctaOutro},format=yuv420p[v]`;

  if (inputs.includes('tts') && inputs.includes('music')) {
    fc += `;[1:a]aresample=44100,pan=stereo|c0=c0|c1=c0,atrim=0:${(duration-0.2).toFixed(2)},apad=pad_dur=${TAIL.toFixed(2)}[voice]` +
          `;[2:a]aresample=44100,volume=0.18,atrim=0:${duration.toFixed(2)}[bg]` +
          `;[voice][bg]amix=inputs=2:duration=longest:normalize=1[mix]`;
  } else if (inputs.includes('tts')) {
    fc += `;[1:a]aresample=44100,atrim=0:${(duration-0.2).toFixed(2)},apad=pad_dur=${TAIL.toFixed(2)}[mix]`;
  } else if (inputs.includes('music')) {
    fc += `;[1:a]aresample=44100,volume=0.18,atrim=0:${duration.toFixed(2)}[mix]`;
  }

  args.push(
    '-filter_complex', fc,
    '-map', '[v]',
    '-map', (inputs.includes('tts') || inputs.includes('music')) ? '[mix]' : '1:a',
    '-r', '24',
    '-c:v', 'libx264', '-preset', 'ultrafast', '-crf', '28', '-pix_fmt', 'yuv420p',
    '-c:a', 'aac', '-b:a', '128k', '-ar', '44100',
    '-movflags', '+faststart',
    '-shortest',
    '-avoid_negative_ts', 'make_zero',
    '-g', '48', '-keyint_min', '24',
    '-loglevel', 'error',
    outPath
  );

  await runSpawn('ffmpeg', args, { killAfter: 70000, killMsg: 'still-video timeout' });

  try { if (imgFile) fs.unlinkSync(imgFile); } catch {}
  try { for (const f of (subsBuild.files||[])) fs.unlinkSync(f); } catch {}

  return { publicUrl: mediaPath(outFile), absoluteUrl: absolutePublicUrl(mediaPath(outFile)) };
}

/* -------------------- Title card (modern + captions) -------------------- */
async function composeTitleCardVideo({ duration, ttsPath = null, musicPath = null, brandLine = 'YOUR BRAND!', ctaText = 'LEARN MORE!', scriptText='' }) {
  const outDir = ensureGeneratedDir();
  const id = uuidv4();
  const outFile = `${id}.mp4`;
  const outPath = path.join(outDir, outFile);

  const sansFile = pickSansFontFile();
  const serifFile = pickSerifFontFile();
  const fontParamSans = sansFile ? `fontfile='${sansFile}':` : `font='Arial':`;
  const fontParamSerif = serifFile ? `fontfile='${serifFile}':` : `font='Times New Roman':`;
  const txtCommon = `fontcolor=white@0.99:borderw=2:bordercolor=black@0.88:shadowx=1:shadowy=1:shadowcolor=black@0.75`;

  const brand = safeFFText(brandLine);
  const cta   = safeFFText(ctaText);
  const TAIL = 0.8;

  const args = ['-y', '-f', 'lavfi', '-t', duration.toFixed(2), '-i', 'color=c=0x101318:s=640x640'];

  const inputs = [];
  if (ttsPath) { args.push('-i', ttsPath); inputs.push('tts'); }
  if (musicPath) { args.push('-i', musicPath); inputs.push('music'); }
  if (!ttsPath && !musicPath) {
    args.push('-f', 'lavfi', '-t', duration.toFixed(2), '-i', 'anullsrc=channel_layout=stereo:sample_rate=44100');
    inputs.push('silence');
  }

  const intro  = `drawtext=${fontParamSans}text='${brand}':${txtCommon}:fontsize=36:x='(w-tw)/2':y='(h/2-88)':enable='between(t,0.3,${(duration-TAIL-0.6).toFixed(2)})'`;
  const ctaFx  = `drawtext=${fontParamSans}text='${cta}':${txtCommon}:box=1:boxcolor=0x0b0d10@0.82:boxborderw=20:fontsize=44:x='(w-tw)/2':y='(h/2)':enable='gte(t,${(duration-TAIL).toFixed(2)})'`;
  const subsBuild = buildCaptionDrawtexts(scriptText, duration, fontParamSerif, id);
  let fc = `[0:v]fps=24,format=yuv420p,${intro}${subsBuild.filter?','+subsBuild.filter:''},${ctaFx},format=yuv420p[v]`;

  if (inputs.includes('tts') && inputs.includes('music')) {
    fc += `;[1:a]aresample=44100,pan=stereo|c0=c0|c1=c0,atrim=0:${(duration-0.2).toFixed(2)},apad=pad_dur=${TAIL.toFixed(2)}[voice]` +
          `;[2:a]aresample=44100,volume=0.18,atrim=0:${duration.toFixed(2)}[bg]` +
          `;[voice][bg]amix=inputs=2:duration=longest:normalize=1[mix]`;
  } else if (inputs.includes('tts')) {
    fc += `;[1:a]aresample=44100,atrim=0:${(duration-0.2).toFixed(2)},apad=pad_dur=${TAIL.toFixed(2)}[mix]`;
  } else if (inputs.includes('music')) {
    fc += `;[1:a]aresample=44100,volume=0.18,atrim=0:${duration.toFixed(2)}[mix]`;
  }

  args.push(
    '-filter_complex', fc,
    '-map', '[v]',
    '-map', (inputs.includes('tts') || inputs.includes('music')) ? '[mix]' : '1:a',
    '-r', '24',
    '-c:v', 'libx264', '-preset', 'ultrafast', '-crf', '28', '-pix_fmt', 'yuv420p',
    '-c:a', 'aac', '-b:a', '128k', '-ar', '44100',
    '-movflags', '+faststart',
    '-shortest',
    '-avoid_negative_ts', 'make_zero',
    '-g', '48', '-keyint_min', '24',
    '-loglevel', 'error',
    outPath
  );

  await runSpawn('ffmpeg', args, { killAfter: 60000, killMsg: 'title-card timeout' });
  try { for (const f of (subsBuild.files||[])) fs.unlinkSync(f); } catch {}

  return { publicUrl: mediaPath(outFile), absoluteUrl: absolutePublicUrl(mediaPath(outFile)) };
}

/* ------------------------------- VIDEO (concat + fades; solid; 3 variations) ------------------------------- */
router.post('/generate-video-ad', heavyLimiter, async (req, res) => {
  try { if (typeof res.setTimeout === 'function') res.setTimeout(180000); if (typeof req.setTimeout === 'function') req.setTimeout(180000); } catch {}
  res.setHeader('Content-Type', 'application/json');

  try {
    const { url = '', answers = {}, regenerateToken = '' } = req.body;

    const token = getUserToken(req);
    const fbAdAccountId = req.body.fbAdAccountId || req.query.adAccountId || req.headers['x-fb-ad-account-id'] || null;

    const category = resolveCategory(answers || {});
    const topic = deriveTopicKeywords(answers, url, 'ecommerce');
    const brandBase = (answers?.businessName && String(answers.businessName).trim()) || overlayTitleFromAnswers(answers, category);
    let brandForVideo = (brandBase || 'Your Brand').toUpperCase().replace(/[^A-Z0-9 \-]/g,'').trim();
    if (!/!$/.test(brandForVideo)) brandForVideo += '!';
    const ctaText = chooseCTA(answers, regenerateToken || answers?.businessName || topic);

    const BUDGET_MS = Number(process.env.AD_GEN_BUDGET_MS || 60000);
    const startTs = Date.now();
    const timeLeft = () => Math.max(0, BUDGET_MS - (Date.now() - startTs));

    /* ---- Script + TTS ---- */
    const forbidFashionLine = category === 'fashion' ? '' : `- Do NOT mention clothing terms like styles, fits, colors, sizes, outfits, wardrobe.`;
    const buildPrompt = (lo, hi) =>
`Write a simple, neutral spoken ad script for an e-commerce/online business in the "${category}" category, about ${topic}.
- About ${lo}-${hi} words.
- Keep it specific to the category, and accurate. ${forbidFashionLine}
- Avoid assumptions (no promises about shipping, returns, guarantees, or inventory).
- Do not include a website or domain.
- Use the CTA phrase exactly once at the end: "${ctaText}".
- Structure: brief hook → value/what to expect → CTA.
Output ONLY the script text.`;

    async function makeTTS(scriptText) {
      const tmpDir = ensureGeneratedDir();
      const file = path.join(tmpDir, `${uuidv4()}.mp3`);
      const ttsRes = await openai.audio.speech.create({ model: 'tts-1', voice: 'alloy', input: scriptText });
      const buf = Buffer.from(await ttsRes.arrayBuffer());
      fs.writeFileSync(file, buf);
      return file;
    }

    let script = '';
    let ttsPath = '';
    let voDur = 0;
    const targets = [[58,72],[70,84]];
    for (let attempt = 0; attempt < targets.length; attempt++) {
      try {
        const [low, high] = targets[attempt];
        const r = await openai.chat.completions.create({
          model: 'gpt-4o',
          messages: [{ role: 'user', content: buildPrompt(low, high) }],
          max_tokens: 320,
          temperature: 0.35
        });
        script = r.choices?.[0]?.message?.content?.trim() || '';
      } catch {
        script = script || `A simple way to support your goals with less hassle. ${ctaText}`;
      }
      script = stripFashionIfNotApplicable(script, category);
      script = enforceCategoryPresence(script, category);
      script = cleanFinalText(script);
      script = finalizeScriptWithSingleCTA(script, ctaText);

      try {
        if (ttsPath) { try { fs.unlinkSync(ttsPath); } catch {} }
        ttsPath = await makeTTS(script);
        voDur = await probeDuration(ttsPath);
        if (voDur >= 14.4) break;
      } catch { ttsPath = null; voDur = 0; break; }
    }

    const TAIL = 0.8;
    const finalDur = Math.max(16.0, Math.min((voDur || 14.4) + TAIL, 30.0));

    /* ---- Background music (optional) ---- */
    let musicPath = null;
    try {
      const keys = [category, answers?.industry, answers?.businessName].filter(Boolean);
      musicPath = pickMusicFile(keys);
    } catch { musicPath = null; }

    const ensureImageForStill = async () => {
      let imageUrl = null;
      if (PEXELS_API_KEY && timeLeft() > 8000) {
        try {
          const keyword = getImageKeyword(answers.industry || '', url) || topic;
          const p = await axios.get(PEXELS_IMG_BASE, {
            headers: { Authorization: PEXELS_API_KEY },
            params: { query: keyword, per_page: 20 },
            timeout: Math.max(3000, Math.min(7000, timeLeft() - 2000))
          });
          const photos = p.data?.photos || [];
          if (photos.length) {
            const idx = (seedrandom(String(regenerateToken || Date.now()))() * photos.length) | 0;
            imageUrl = photos[idx].src.large2x || photos[idx].src.original || photos[idx].src.large || null;
          }
        } catch {}
      }
      if (!imageUrl) imageUrl = await getRecentImageForOwner(req);
      if (!imageUrl) imageUrl = 'https://picsum.photos/seed/smartmark/1200/1200';
      return imageUrl;
    };

    const generateOneVariant = async (seedBump = '') => {
      /* ---- Tier 1: stock montage with simple fades (rock-solid) ---- */
      const tryStockVideo = async () => {
        if (!PEXELS_API_KEY) throw new Error('no_pexels_key');
        if (timeLeft() < 15000) throw new Error('time_budget_low');

        let candidates = [];
        const r = await axios.get('https://api.pexels.com/videos/search', {
          headers: { Authorization: PEXELS_API_KEY },
          params: { query: topic, per_page: 30, cb: Date.now() + (regenerateToken || '') + seedBump },
          timeout: Math.max(3000, Math.min(7000, timeLeft() - 2000))
        });
        const videos = r.data?.videos || [];
        for (const v of videos) {
          if ((v.duration || 0) < 7) continue;
          const files = (v.video_files || [])
            .filter(f => f?.link && /\.mp4(\?|$)/i.test(f.link))
            .sort((a, b) => (a.width || 9999) - (b.width || 9999));
          if (files[0]?.link) candidates.push({ link: files[0].link, duration: v.duration || 8 });
        }
        if (candidates.length < 3) throw new Error('not_enough_clips');

        const chosen = getDeterministicShuffle(candidates, (regenerateToken || answers?.businessName || topic || Date.now()) + '_' + seedBump).slice(0, 3);
        const tmp = path.join(__dirname, '../tmp');
        try { fs.mkdirSync(tmp, { recursive: true }); } catch {}
        const inputs = [];
        for (const c of chosen) {
          if (timeLeft() < 6000) break;
          const out = path.join(tmp, `${uuidv4()}.mp4`);
          const dlTimeout = Math.max(6000, Math.min(14000, timeLeft() - 3000));
          await downloadFileWithTimeout(c.link, out, dlTimeout, 6);
          inputs.push(out);
        }
        if (inputs.length < 3) throw new Error('downloads_incomplete');

        const sansFile = pickSansFontFile();
        const serifFile = pickSerifFontFile();
        const fontParamSans = sansFile ? `fontfile='${sansFile}':` : `font='Arial':`;
        const fontParamSerif = serifFile ? `fontfile='${serifFile}':` : `font='Times New Roman':`;
        const brandLine = safeFFText(brandForVideo);
        const ctaTxt    = safeFFText(ctaText);
        const TOP_H   = Math.round(640 * 0.18);
        const txtCommon = `fontcolor=white@0.99:borderw=2:bordercolor=black@0.88:shadowx=1:shadowy=1:shadowcolor=black@0.75`;

        // segment lengths
        const segA = Math.min(6.2, Math.max(4.8, finalDur * 0.36));
        const segB = Math.max(4.2, (finalDur - segA) / 2);
        const segC = Math.max(4.0, finalDur - segA - segB);
        const segs = [segA, segB, segC];

        const introStart = 0.25;
        const introEnd   = Math.min(segA - 0.25, 3.2);
        const outroStart = Math.max(0.0, finalDur - TAIL);
        const outroEnd   = finalDur;

        const baseLook = `setsar=1,fps=24,format=yuv420p,settb=AVTB`;
        const LEAD = 0.06;
        const fadeDur = 0.35;

        const vidParts = [];
        for (let i = 0; i < inputs.length; i++) {
          const seg = segs[i];
          // Trim to seg then fade in/out inside each segment
          const fadeIn = i===0 ? `,fade=t=in:st=0:d=${fadeDur}` : `,fade=t=in:st=0:d=${fadeDur}`;
          const fadeOut = `,fade=t=out:st=${(seg - fadeDur).toFixed(2)}:d=${fadeDur}`;
          vidParts.push(
            `[${i}:v]scale='if(gte(iw/ih,1),640,-2)':'if(gte(iw/ih,1),-2,640)',` +
            `pad=640:640:(640-iw)/2:(640-ih)/2,${baseLook},trim=${LEAD}:${(LEAD + seg).toFixed(2)},setpts=PTS-STARTPTS${fadeIn}${fadeOut}[s${i}]`
          );
        }

        const concat = `[s0][s1][s2]concat=n=3:v=1:a=0[vseq]`;

        const bandFadeStart = (segA-0.60).toFixed(2);
        const band =
          `color=c=black@0.52:s=640x${TOP_H}:d=${finalDur.toFixed(2)},format=rgba,fade=t=out:st=${bandFadeStart}:d=0.6:alpha=1[top];` +
          `[vseq][top]overlay=shortest=1:x=0:y=0[b3]`;

        const introOverlay =
          `drawtext=${fontParamSans}text='${brandLine}':${txtCommon}:fontsize=30:x=(w-tw)/2:y=${Math.round(TOP_H*0.56)}:enable='between(t,${(introStart+0.10).toFixed(2)},${introEnd.toFixed(2)})'`;
        const outroOverlay =
          `drawtext=${fontParamSans}text='${ctaTxt}':${txtCommon}:box=1:boxcolor=0x0b0d10@0.82:boxborderw=20:fontsize=44:x=(w-tw)/2:y=(h/2-16):enable='between(t,${outroStart.toFixed(2)},${outroEnd.toFixed(2)})'`;

        const subsBuild = buildCaptionDrawtexts(script, finalDur, fontParamSerif, `v${seedBump}`);

        let fc = vidParts.join(';') + ';' + concat + ';' + band + `;[b3]${introOverlay}${subsBuild.filter?','+subsBuild.filter:''},${outroOverlay},format=yuv420p[v]`;

        const outDir = ensureGeneratedDir();
        const outFile = `${uuidv4()}.mp4`;
        const outPath = path.join(outDir, outFile);

        const args = ['-y'];
        for (const f of inputs) { args.push('-i', f); }
        if (ttsPath) args.push('-i', ttsPath);
        if (musicPath) args.push('-i', musicPath);
        else args.push('-f', 'lavfi', '-t', finalDur.toFixed(2), '-i', 'anullsrc=channel_layout=stereo:sample_rate=44100');

        if (ttsPath && musicPath) {
          fc += `;[${inputs.length}:a]aresample=44100,pan=stereo|c0=c0|c1=c0,atrim=0:${(voDur>0?voDur:finalDur).toFixed(2)},apad=pad_dur=${TAIL.toFixed(2)}[voice]` +
                `;[${inputs.length+1}:a]aresample=44100,volume=0.18,atrim=0:${(voDur>0?voDur+TAIL:finalDur).toFixed(2)}[bg]` +
                `;[voice][bg]amix=inputs=2:duration=longest:normalize=1[mix]`;
        } else if (ttsPath) {
          fc += `;[${inputs.length}:a]aresample=44100,atrim=0:${(voDur>0?voDur:finalDur).toFixed(2)},apad=pad_dur=${TAIL.toFixed(2)}[mix]`;
        } else if (musicPath) {
          fc += `;[${inputs.length}:a]aresample=44100,volume=0.18,atrim=0:${finalDur.toFixed(2)}[mix]`;
        } else {
          fc += `;[${inputs.length}:a]anull[aud]`; // silence input
        }

        args.push(
          '-filter_complex', fc,
          '-map', '[v]',
          '-map', (ttsPath || musicPath) ? '[mix]' : `${inputs.length}:a`,
          '-t', finalDur.toFixed(2),
          '-r', '24',
          '-vsync', '2',
          '-c:v', 'libx264', '-preset', 'ultrafast', '-crf', '28', '-pix_fmt', 'yuv420p',
          '-g', '48', '-keyint_min', '24',
          '-c:a', 'aac', '-b:a', '128k', '-ar', '44100',
          '-movflags', '+faststart',
          '-avoid_negative_ts', 'make_zero',
          '-loglevel', 'error',
          outPath
        );

        await runSpawn('ffmpeg', args, { killAfter: 65000, killMsg: 'montage timeout' });
        for (const f of inputs) { try { fs.unlinkSync(f); } catch {} }
        try { for (const f of (subsBuild.files||[])) fs.unlinkSync(f); } catch {}

        return { publicUrl: mediaPath(outFile), absoluteUrl: absolutePublicUrl(mediaPath(outFile)) };
      };

      let videoUrl = '';
      let absoluteUrl = '';
      try {
        const stock = await tryStockVideo();
        videoUrl = stock.publicUrl; absoluteUrl = stock.absoluteUrl;
      } catch {
        try {
          const imageUrl = await ensureImageForStill();
          const still = await composeStillVideo({
            imageUrl,
            duration: finalDur,
            ttsPath,
            musicPath,
            brandLine: brandForVideo,
            ctaText,
            scriptText: script
          });
          videoUrl = still.publicUrl; absoluteUrl = still.absoluteUrl;
        } catch {
          const title = await composeTitleCardVideo({
            duration: finalDur,
            ttsPath,
            musicPath,
            brandLine: brandForVideo,
            ctaText,
            scriptText: script
          });
          videoUrl = title.publicUrl; absoluteUrl = title.absoluteUrl;
        }
      }

      await saveAsset({
        req,
        kind: 'video',
        url: videoUrl,
        absoluteUrl,
        meta: { script, ctaText, voice: ttsPath ? 'alloy' : null, hasMusic: !!musicPath, topic, category }
      });

      return { url: videoUrl, absoluteUrl };
    };

    const variations = [];
    for (let i = 0; i < 3; i++) {
      try { variations.push(await generateOneVariant(String(i))); } catch {}
      if (timeLeft() < 2500) break;
    }

    // optional upload to FB
    let fbVideoId = null;
    try {
      if (variations[0] && fbAdAccountId && token) {
        const up = await uploadVideoToAdAccount(
          fbAdAccountId, token, variations[0].absoluteUrl,
          'SmartMark Generated Video', 'Generated by SmartMark'
        );
        fbVideoId = up?.id || null;
      }
    } catch {}

    try { if (ttsPath) fs.unlinkSync(ttsPath); } catch {}
    maybeGC();

    const first = variations[0] || { url: '', absoluteUrl: '' };

    return res.json({
      videoUrl: first.url,
      absoluteVideoUrl: first.absoluteUrl,
      fbVideoId,
      script,
      ctaText,
      voice: ttsPath ? 'alloy' : null,
      hasMusic: !!musicPath,
      video: { url: first.url, script, overlayText: ctaText, voice: ttsPath ? 'alloy' : null, hasMusic: !!musicPath },
      videoVariations: variations.map(v => ({ url: v.url, absoluteUrl: v.absoluteUrl }))
    });
  } catch (err) {
    if (!res.headersSent)
      return res.status(500).json({ error: 'Failed to generate video ad', detail: err?.message || 'Unknown error' });
  }
});

/* --------------------- IMAGE: search + overlay (3 variations) --------------------- */
router.post('/generate-image-from-prompt', heavyLimiter, async (req, res) => {
  try { if (typeof res.setTimeout === 'function') res.setTimeout(60000); if (typeof req.setTimeout === 'function') req.setTimeout(60000); } catch {}
  try {
    const { regenerateToken = '' } = req.body;
    const top = req.body || {};
    const answers = top.answers || top;
    const url = answers.url || top.url || '';
    const industry = answers.industry || top.industry || '';
    const category = resolveCategory(answers || {});
    const keyword = getImageKeyword(industry, url);

    const makeOne = async (baseUrl, seed) => {
      const headlineHint = overlayTitleFromAnswers(answers, category);
      const ctaHint = pickFromAllowedCTAs(answers, seed);
      try {
        const { publicUrl, absoluteUrl } = await buildOverlayImage({
          imageUrl: baseUrl,
          headlineHint,
          ctaHint,
          seed,
          fallbackHeadline: headlineHint
        });
        await saveAsset({
          req,
          kind: 'image',
          url: publicUrl,
          absoluteUrl,
          meta: { keyword, overlayText: ctaHint, headlineHint, category }
        });
        return publicUrl;
      } catch {
        await saveAsset({
          req,
          kind: 'image',
          url: baseUrl,
          absoluteUrl: baseUrl,
          meta: { keyword, overlayText: ctaHint, headlineHint, raw: true, category }
        });
        return baseUrl;
      }
    };

    if (!PEXELS_API_KEY) {
      const urls = [];
      for (let i=0;i<3;i++){
        const { publicUrl, absoluteUrl } = await buildOverlayImage({
          imageUrl: 'https://picsum.photos/seed/smartmark'+i+'/1200/627',
          headlineHint: overlayTitleFromAnswers(answers, category),
          ctaHint: pickFromAllowedCTAs(answers, regenerateToken + '_' + i),
          seed: regenerateToken + '_' + i,
          fallbackHeadline: overlayTitleFromAnswers(answers, category)
        });
        await saveAsset({ req, kind: 'image', url: publicUrl, absoluteUrl, meta: { category, keyword, placeholder: true, i } });
        urls.push(publicUrl);
      }
      return res.json({ imageUrl: urls[0], keyword, totalResults: 3, usedIndex: 0, imageVariations: urls.map(u => ({ url: u })) });
    }

    let photos = [];
    try {
      const r = await axios.get(PEXELS_IMG_BASE, {
        headers: { Authorization: PEXELS_API_KEY },
        params: { query: keyword, per_page: 35, cb: Date.now() + (regenerateToken || '') },
        timeout: 7000
      });
      photos = r.data.photos || [];
    } catch {
      return res.status(500).json({ error: 'Image search failed' });
    }
    if (!photos.length) return res.status(404).json({ error: 'No images found.' });

    const seed = regenerateToken || answers?.businessName || keyword || Date.now();
    let idxHash = 0; for (const c of String(seed)) idxHash = (idxHash*31 + c.charCodeAt(0))>>>0;

    // pick 3 distinct indices
    const picks = [];
    for (let i=0;i<photos.length && picks.length<3;i++){
      const idx = (idxHash + i*7) % photos.length;
      if (!picks.includes(idx)) picks.push(idx);
    }

    const urls = [];
    for (let pi=0; pi<picks.length; pi++){
      const img = photos[picks[pi]];
      const baseUrl = img.src.large2x || img.src.original || img.src.large;
      const u = await makeOne(baseUrl, seed + '_' + pi);
      urls.push(u);
    }

    const img0 = photos[picks[0]];
    res.json({
      imageUrl: urls[0],
      photographer: img0?.photographer,
      pexelsUrl: img0?.url,
      keyword,
      totalResults: photos.length,
      usedIndex: picks[0],
      imageVariations: urls.map(u => ({ url: u }))
    });
  } catch (e) {
    res.status(500).json({ error: 'Failed to fetch stock image', detail: e.message });
  }
});

/* ------------------------- RECENT (24h window) ------------------------- */
async function listRecentForOwner(req) {
  await purgeExpiredAssets();
  const owner = ownerKeyFromReq(req);
  return (db.data.generated_assets || [])
    .filter(a => a.owner === owner)
    .sort((a, b) => b.createdAt - a.createdAt)
    .slice(0, 50);
}
router.get('/recent', async (req, res) => {
  try { const items = await listRecentForOwner(req); res.json({ items, ttlMs: ASSET_TTL_MS }); }
  catch { res.status(500).json({ error: 'Failed to load recent assets' }); }
});
router.get('/assets/recent', async (req, res) => {
  try { const items = await listRecentForOwner(req); res.json({ items, ttlMs: ASSET_TTL_MS }); }
  catch { res.status(500).json({ error: 'Failed to load recent assets' }); }
});
router.get('/recent-assets', async (req, res) => {
  try { const items = await listRecentForOwner(req); res.json({ items, ttlMs: ASSET_TTL_MS }); }
  catch { res.status(500).json({ error: 'Failed to load recent assets' }); }
});

/* optional: clear recent (for testing/UX reset) */
router.post('/assets/clear', async (req, res) => {
  try {
    await ensureAssetsTable();
    const owner = ownerKeyFromReq(req);
    db.data.generated_assets = (db.data.generated_assets || []).filter(a => a.owner !== owner);
    await db.write();
    res.json({ success: true });
  } catch {
    res.status(500).json({ error: 'Failed to clear assets' });
  }
});

module.exports = router;
