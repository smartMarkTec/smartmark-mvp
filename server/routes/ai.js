// server/routes/ai.js
'use strict';

const express = require('express');
const router = express.Router();

// --- CORS for Vercel frontend (API only) ---
const ALLOW_ORIGINS = new Set([
  'http://localhost:3000',
  'http://127.0.0.1:3000',
  'https://smartmark-mvp.vercel.app',
  process.env.FRONTEND_ORIGIN,
].filter(Boolean));

router.use((req, res, next) => {
  const origin = req.headers.origin;
  if (origin && ALLOW_ORIGINS.has(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }
  res.setHeader('Vary', 'Origin');
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PUT,PATCH,DELETE,OPTIONS');
  // include x-fb-ad-account-id for your header usage
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With, X-FB-AD-ACCOUNT-ID');
  res.setHeader('Access-Control-Max-Age', '86400');
  if (req.method === 'OPTIONS') return res.sendStatus(204);
  next();
});

const axios = require('axios');
const fs = require('fs');
const path = require('path');
const sharp = require('sharp');
const { v4: uuidv4 } = require('uuid');
const FormData = require('form-data');
const child_process = require('child_process');
const util = require('util');
const exec = util.promisify(child_process.exec);
const seedrandom = require('seedrandom');
const { OpenAI } = require('openai');
const { getFbUserToken } = require('../tokenStore');

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const PEXELS_API_KEY = process.env.PEXELS_API_KEY;

// ---------- helpers ----------
function absolutePublicUrl(relativePath) {
  const base = process.env.PUBLIC_BASE_URL || process.env.RENDER_EXTERNAL_URL || 'https://smartmark-mvp.onrender.com';
  if (!relativePath) return '';
  if (/^https?:\/\//i.test(relativePath)) return relativePath;
  return `${base}${relativePath}`;
}
function getUserToken(req) {
  return req?.body?.userAccessToken || getFbUserToken() || null;
}
async function uploadVideoToAdAccount(adAccountId, userAccessToken, fileUrl, name = 'SmartMark Video', description = 'Generated by SmartMark') {
  const url = `https://graph.facebook.com/v23.0/act_${String(adAccountId).replace(/^act_/, '')}/advideos`;
  const form = new FormData();
  form.append('file_url', fileUrl);
  form.append('name', name);
  form.append('description', description);
  const resp = await axios.post(url, form, { headers: form.getHeaders(), params: { access_token: userAccessToken } });
  return resp.data;
}

// Where server serves /generated from
function ensureGeneratedDir() {
  const outDir = process.env.RENDER ? '/tmp/generated' : path.join(__dirname, '../public/generated');
  try { fs.mkdirSync(outDir, { recursive: true }); } catch {}
  return outDir;
}

// Pick topic keywords tightly tied to user input so clips are on-topic
function deriveTopicKeywords(answers = {}, url = '', fallback = 'shopping') {
  const industry = answers.industry || answers.productType || '';
  const kw = getImageKeyword(industry, url);
  const extra = String(answers.description || answers.product || answers.mainBenefit || '').toLowerCase();
  if (extra.includes('coffee')) return 'coffee shop';
  if (extra.includes('protein') || extra.includes('fitness') || extra.includes('gym')) return 'gym workout';
  if (extra.includes('makeup') || extra.includes('skincare') || extra.includes('cosmetic')) return 'makeup application';
  if (extra.includes('fashion') || extra.includes('clothes') || extra.includes('apparel')) return 'fashion model';
  if (extra.includes('hair')) return 'hair care';
  if (extra.includes('pet') || extra.includes('dog') || extra.includes('cat')) return 'pet dog cat';
  if (extra.includes('electronics') || extra.includes('phone') || extra.includes('laptop')) return 'tech gadgets';
  return kw || industry || fallback;
}

// ---------- training context ----------
const DATA_DIR = path.join(__dirname, '../data');
const ALLOWED_EXT = new Set(['.txt', '.md', '.markdown', '.json']);
const MAX_FILE_MB = 1.5;
const MAX_TOTAL_CHARS = 45_000;
function loadTrainingContext() {
  if (!fs.existsSync(DATA_DIR)) return '';
  const files = fs.readdirSync(DATA_DIR)
    .map(f => path.join(DATA_DIR, f))
    .filter(full => {
      const ext = path.extname(full).toLowerCase();
      try {
        const st = fs.statSync(full);
        return st.isFile() && ALLOWED_EXT.has(ext) && st.size <= MAX_FILE_MB * 1024 * 1024;
      } catch { return false; }
    });
  let ctx = '';
  for (const f of files) {
    try {
      const ext = path.extname(f).toLowerCase();
      let text = fs.readFileSync(f, 'utf8');
      if (ext === '.json') { try { text = JSON.stringify(JSON.parse(text)); } catch {} }
      if (!text.trim()) continue;
      const block = `\n\n### SOURCE: ${path.basename(f)}\n${text}\n`;
      if (ctx.length + block.length <= MAX_TOTAL_CHARS) ctx += block;
    } catch {}
  }
  return ctx.trim();
}
let customContext = loadTrainingContext();

// ---------- scrape & test ----------
router.get('/test', (_req, res) => res.json({ msg: 'AI route is working!' }));

async function getWebsiteText(url) {
  try {
    const clean = String(url || '').trim();
    if (!clean || !/^https?:\/\//i.test(clean)) throw new Error('Invalid URL');
    const { data, headers } = await axios.get(clean, { timeout: 7000, maxRedirects: 3, validateStatus: s => s < 400 });
    if (!headers['content-type']?.includes('text/html')) throw new Error('Not HTML');
    const body = String(data)
      .replace(/<script[\s\S]*?<\/script>/gi, '')
      .replace(/<style[\s\S]*?<\/style>/gi, '')
      .replace(/<[^>]+>/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
    if (body.length < 200 || /cloudflare|access denied|429/i.test(body)) throw new Error('blocked/short');
    return body.slice(0, 3500);
  } catch (e) {
    console.warn('scrape fail:', url || '(empty)', e.message);
    return '';
  }
}

// ---------- ad copy ----------
router.post('/generate-ad-copy', async (req, res) => {
  const { description = '', businessName = '', url = '' } = req.body;
  if (!description && !businessName && !url) return res.status(400).json({ error: 'Please provide at least a description.' });

  let prompt =
`You are an expert direct-response ad copywriter.
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}Write only the exact words for a spoken video ad script (60–80 words) which is ~15–17 seconds at normal pace. Hook → benefit → strong CTA. Friendly, simple, conversion-focused. Do NOT say or hint a URL or domain.`;
  if (description) prompt += `\nBusiness Description: ${description}`;
  if (businessName) prompt += `\nBusiness Name: ${businessName}`;
  if (url) prompt += `\nWebsite (for context only): ${url}`;
  prompt += `\nOutput ONLY the script text.`;

  try {
    const r = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 170,
      temperature: 0.35
    });
    res.json({ adCopy: r.choices?.[0]?.message?.content?.trim() || '' });
  } catch (e) {
    console.error('adcopy fail:', e?.response?.data || e.message);
    res.status(500).json({ error: 'Failed to generate ad copy' });
  }
});

// ---------- generate-campaign-assets ----------
router.post('/generate-campaign-assets', async (req, res) => {
  try {
    const { answers = {}, url = '' } = req.body;

    const brandFromUrl = (u = '') => {
      try {
        const h = new URL(u).hostname.replace(/^www\./, '');
        const base = h.split('.')[0] || 'Your Brand';
        return base.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
      } catch { return 'Your Brand'; }
    };
    const brand = (answers.businessName && String(answers.businessName).trim()) || brandFromUrl(url);
    const industry = (answers.industry && String(answers.industry).trim()) || '';
    const mainBenefit = (answers.mainBenefit && String(answers.mainBenefit).trim()) || '';
    const offer = (answers.offer && String(answers.offer).trim()) || '';

    let websiteText = '';
    try { if (url && /^https?:\/\//i.test(url)) websiteText = await getWebsiteText(url); } catch {}

    const prompt = `
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}You are a senior direct-response copywriter.
Write JSON ONLY:

{
  "headline": "max 55 characters, plain, natural, no weird jargon",
  "body": "18-30 words, friendly, value+benefit, no emojis, no hashtags",
  "image_overlay_text": "3-4 words, generic CTA or benefit, ALL CAPS"
}

Rules:
- Prefer simple phrasing (avoid odd terms like "unisex fashion-forward" or "global finds").
- If unsure, default to very generic e-commerce phrasing.
- Do NOT include the website/domain anywhere.
- No quotes around fields beyond JSON syntax.
Context:
Brand: ${brand}
Industry: ${industry || '[general ecommerce]'}
Main benefit: ${mainBenefit || '[unspecified]'}
Offer: ${offer || '[none]'}
Website text (may be empty): """${(websiteText || '').slice(0, 1200)}"""`.trim();

    let headline = '', body = '', overlay = '';
    try {
      const r = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 220,
        temperature: 0.35
      });
      const raw = r.choices?.[0]?.message?.content?.trim() || '{}';
      const jsonStr = (raw.match(/\{[\s\S]*\}/) || [raw])[0];
      const parsed = JSON.parse(jsonStr);

      const clean = (s, max = 200) => String(s || '').replace(/\s+/g, ' ').trim().slice(0, max);
      headline = clean(parsed.headline, 55);
      body = clean(parsed.body, 220);
      overlay = clean(parsed.image_overlay_text, 28);
    } catch {
      headline = `${brand}: Shop New Arrivals`;
      body = `Discover quality picks for everyday life. Fast shipping, easy returns, and friendly support—see what’s new today.`;
      overlay = 'SHOP NOW';
    }

    headline = headline.replace(/["<>]/g, '').slice(0, 55);
    body = body.replace(/["<>]/g, '').replace(/\s+/g, ' ').trim();
    overlay = overlay.toUpperCase().replace(/[^A-Z0-9\s!]/g, '').replace(/\s+/g, ' ').trim();
    if (!overlay) overlay = 'SHOP NOW';

    return res.json({ headline, body, image_overlay_text: overlay });
  } catch (e) {
    console.error('generate-campaign-assets error:', e?.message || e);
    return res.json({
      headline: 'Shop Our Latest Picks',
      body: 'Quality products, fast shipping, and easy returns. Simple, reliable, and ready when you are—see what’s new today.',
      image_overlay_text: 'SHOP NOW'
    });
  }
});

// ---------- audience ----------
const DEFAULT_AUDIENCE = {
  brandName: '', demographic: '', ageRange: '18-65',
  location: 'US', interests: 'Business, Restaurants', fbInterestIds: [], summary: ''
};

async function extractKeywords(text) {
  const prompt = `
Extract up to 6 compact keywords (one or two words each) from this text that would be useful Facebook interest seeds.
Return them as a comma-separated list ONLY. No extra words.

TEXT:
"""${(text || '').slice(0, 3000)}"""`.trim();

  try {
    const r = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 40,
      temperature: 0.2
    });
    return (r.choices?.[0]?.message?.content || '')
      .replace(/[\n.]/g, '')
      .toLowerCase()
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);
  } catch { return []; }
}

async function getFbInterestIds(keywords, fbToken) {
  const out = [];
  for (const k of keywords) {
    try {
      const r = await axios.get('https://graph.facebook.com/v18.0/search', {
        params: { type: 'adinterest', q: k, access_token: fbToken, limit: 1 }
      });
      if (r.data?.data?.[0]?.id) out.push({ id: r.data.data[0].id, name: r.data.data[0].name });
    } catch {}
  }
  return out;
}

router.post('/detect-audience', async (req, res) => {
  const { url } = req.body;
  const fbToken = req.body.fbToken || getFbUserToken();
  if (!url) return res.status(400).json({ error: 'Missing URL' });

  const websiteText = await getWebsiteText(url);
  const safe = websiteText.length > 100 ? websiteText : '[WEBSITE TEXT UNAVAILABLE]';

  const prompt = `
${customContext ? `TRAINING CONTEXT:\n${customContext}\n\n` : ''}
Answer ONLY this JSON:
{"brandName":"","demographic":"","ageRange":"","location":"","interests":"","summary":""}
Website homepage text:
"""${safe}"""`.trim();

  try {
    const r = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 220,
      temperature: 0.3
    });

    const txt = r.choices?.[0]?.message?.content?.trim() || '{}';
    let aud;
    try {
      const m = txt.match(/\{[\s\S]*\}/);
      aud = JSON.parse(m ? m[0] : txt);
      aud = {
        brandName: aud.brandName || '',
        demographic: aud.demographic || '',
        ageRange: /^\d{2}-\d{2}$/.test(aud.ageRange || '') ? aud.ageRange : '18-65',
        location: (aud.location || 'US').toString().trim().toUpperCase() || 'US',
        interests: aud.interests || 'Business, Restaurants',
        summary: aud.summary || ''
      };
    } catch {
      return res.json({ audience: DEFAULT_AUDIENCE });
    }

    if (fbToken) {
      const kws = await extractKeywords(websiteText);
      const fb = await getFbInterestIds(kws, fbToken);
      aud.fbInterestIds = fb.map(i => i.id);
      aud.fbInterestNames = fb.map(i => i.name);
    } else {
      aud.fbInterestIds = [];
      aud.fbInterestNames = [];
    }
    res.json({ audience: aud });
  } catch {
    res.json({ audience: DEFAULT_AUDIENCE });
  }
});

// ---------- image helpers & overlay ----------
const PEXELS_IMG_BASE = 'https://api.pexels.com/v1/search';
const IMAGE_KEYWORD_MAP = [
  { match: ['protein powder','protein','supplement','muscle','fitness','gym'], keyword: 'gym workout' },
  { match: ['clothing','fashion','apparel','accessory'], keyword: 'fashion model' },
  { match: ['makeup','cosmetic','skincare'], keyword: 'makeup application' },
  { match: ['hair','shampoo'], keyword: 'hair care' },
  { match: ['food','pizza','burger','meal','snack'], keyword: 'delicious food' },
  { match: ['baby','kids','toys'], keyword: 'happy children' },
  { match: ['pet','dog','cat'], keyword: 'pet dog cat' },
  { match: ['electronics','phone','laptop','tech'], keyword: 'tech gadgets' },
  { match: ['home','kitchen','decor'], keyword: 'modern home' },
  { match: ['art','painting','craft'], keyword: 'painting art' },
  { match: ['coffee','cafe'], keyword: 'coffee shop' },
];
function getImageKeyword(industry = '', url = '') {
  const input = `${industry} ${url}`.toLowerCase();
  for (const row of IMAGE_KEYWORD_MAP) if (row.match.some(m => input.includes(m))) return row.keyword;
  return industry || 'ecommerce';
}
function escSVG(s){return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;')}
function estWidth(text, fs){return (String(text||'').length||1)*fs*0.56}
function fitFont(text, maxW, startFs, minFs=30){let fs=startFs;while(fs>minFs&&estWidth(text,fs)>maxW)fs-=2;return fs}
function splitTwoLines(text,maxW,startFs){
  const words=String(text||'').split(/\s+/).filter(Boolean);
  if(words.length<=2)return{lines:[text],fs:fitFont(text,maxW,startFs)};
  for(let cut=Math.ceil(words.length/2);cut<words.length-1;cut++){
    const a=words.slice(0,cut).join(' '),b=words.slice(cut).join(' ');
    let fs=startFs;fs=Math.min(fitFont(a,maxW,fs),fitFont(b,maxW,fs));
    if(estWidth(a,fs)<=maxW && estWidth(b,fs)<=maxW) return {lines:[a,b],fs};
  }
  return {lines:[text],fs:fitFont(text,maxW,startFs)};
}
const BANNED_TERMS = /\b(unisex|global|vibes?|forward|finds?|chic|bespoke|avant|couture)\b/i;
function cleanHeadline(h){
  h=String(h||'').replace(/[^a-z0-9 &\-]/gi,' ').replace(/\s+/g,' ').trim();
  if(!h || BANNED_TERMS.test(h)) return '';
  const words=h.split(' '); if(words.length<2||words.length>4) return '';
  return h.toUpperCase();
}
function cleanCTA(c){
  c=String(c||'').replace(/[^a-z0-9 &\-]/gi,' ').replace(/\s+/g,' ').trim();
  if(!c) return 'Shop Now!';
  let w=c.split(' ').slice(0,3).join(' ');
  if(!/[.!?]$/.test(w)) w+='!';
  return w.charAt(0).toUpperCase()+w.slice(1);
}
const FALLBACK_HEADLINES = ['New Arrivals','Everyday Style','Modern Looks','Wardrobe Refresh','Great Picks Today','Everyday Essentials'];
const FALLBACK_CTA = ['Shop Now!','See More!','Learn More!'];

// --- CTA box helper for SVG (white text on dark box) ---
function ctaBox(xRight, y, text, fs=26, padX=14, padY=10){
  const w=estWidth(text,fs)+padX*2, h=fs+padY*2, x=xRight-w;
  return `
    <rect x="${x}" y="${y-h+4}" width="${w}" height="${h}" rx="10" fill="#0b0d10cc"/>
    <text x="${x+padX}" y="${y-padY}" font-family="Helvetica, Arial, sans-serif" font-size="${fs}" font-weight="800" fill="#ffffff">
      ${escSVG(text)}
    </text>`;
}

function renderImageSVG({ W, H, base64, headline, cta, tpl=1 }) {
  const LIGHT = '#f2f5f6'; const MAX_W = W - 80;
  if (tpl === 1) {
    let fs = fitFont(headline, MAX_W-80, 56);
    return `<svg width="${W}" height="${H}" xmlns="http://www.w3.org/2000/svg">
      <defs><linearGradient id="g1" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#0000"/><stop offset="100%" stop-color="#000a"/></linearGradient></defs>
      <image href="data:image/jpeg;base64,${base64}" x="0" y="0" width="${W}" height="${H}"/>
      <rect x="0" y="${H-140}" width="${W}" height="140" fill="url(#g1)"/>
      <text x="40" y="${H-56}" font-family="Times New Roman, Times, serif" font-size="${fs}" font-weight="700" fill="${LIGHT}" letter-spacing="2">${escSVG(headline)}</text>
      ${ctaBox(W-40, H-52, cta, 26)}
    </svg>`;
  }
  if (tpl === 2) {
    let fs = fitFont(headline, MAX_W-80, 56);
    return `<svg width="${W}" height="${H}" xmlns="http://www.w3.org/2000/svg">
      <defs><linearGradient id="g2" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#000a"/><stop offset="100%" stop-color="#0000"/></linearGradient></defs>
      <image href="data:image/jpeg;base64,${base64}" x="0" y="0" width="${W}" height="${H}"/>
      <rect x="0" y="0" width="${W}" height="140" fill="url(#g2)"/>
      <text x="40" y="92" font-family="Times New Roman, Times, serif" font-size="${fs}" font-weight="700" fill="${LIGHT}" letter-spacing="2">${escSVG(headline)}</text>
      ${ctaBox(W-40, 98, cta, 26)}
    </svg>`;
  }
  if (tpl === 3) {
    const boxW = 860; const fit = splitTwoLines(headline, boxW-80, 56); const y0 = (H/2) - (fit.lines.length===2?12:0);
    return `<svg width="${W}" height="${H}" xmlns="http://www.w3.org/2000/svg">
      <image href="data:image/jpeg;base64,${base64}" x="0" y="0" width="${W}" height="${H}"/>
      <rect x="${(W-boxW)/2}" y="${(H-160)/2}" width="${boxW}" height="160" rx="20" fill="#00000028"/>
      <text x="${W/2}" y="${y0}" text-anchor="middle" font-family="Times New Roman, Times, serif" font-size="${fit.fs}" font-weight="700" fill="#f2f5f6" letter-spacing="2">
        <tspan x="${W/2}" dy="0">${escSVG(fit.lines[0])}</tspan>
        ${fit.lines[1]?`<tspan x="${W/2}" dy="${fit.fs*1.05}">${escSVG(fit.lines[1])}</tspan>`:''}
      </text>
      <g transform="translate(${W/2 - estWidth(cta,26)/2 - 18}, ${H/2 + 20})">
        <rect x="0" y="-28" width="${estWidth(cta,26)+36}" height="44" rx="10" fill="#0b0d10cc"/>
        <text x="18" y="0" font-family="Helvetica, Arial, sans-serif" font-size="26" font-weight="800" fill="#ffffff">${escSVG(cta)}</text>
      </g>
    </svg>`;
  }
  const targetFs = 56;
  const fit = splitTwoLines(headline, W*0.6, targetFs);
  const needed = Math.min(W*0.7, Math.max(360, Math.max(...fit.lines.map(line => estWidth(line, fit.fs))) + 140));
  const leftPad = 28;
  const topY = H/2 - (fit.lines.length === 2 ? fit.fs*0.6 : fit.fs*0.2);
  return `<svg width="${W}" height="${H}" xmlns="http://www.w3.org/2000/svg">
    <image href="data:image/jpeg;base64,${base64}" x="0" y="0" width="${W}" height="${H}"/>
    <rect x="0" y="0" width="${needed}" height="${H}" fill="#0b0d10aa"/>
    <text x="${leftPad+12}" y="${topY}" font-family="Times New Roman, Times, serif" font-size="${fit.fs}" font-weight="700" fill="#f2f5f6" letter-spacing="2">
      <tspan x="${leftPad+12}" dy="0">${escSVG(fit.lines[0])}</tspan>
      ${fit.lines[1]?`<tspan x="${leftPad+12}" dy="${fit.fs*1.05}">${escSVG(fit.lines[1])}</tspan>`:''}
    </text>
    ${ctaBox(leftPad+needed-24, topY + (fit.lines.length===2 ? fit.fs*2.0 : fit.fs*1.4), cta, 26)}
  </svg>`;
}

async function buildOverlayImage({ imageUrl, headlineHint = '', ctaHint = '', seed = '' }) {
  const W = 1200, H = 627;
  const imgRes = await axios.get(imageUrl, { responseType: 'arraybuffer' });
  const baseBuf = await sharp(imgRes.data).resize(W, H, { fit: 'cover' }).jpeg({ quality: 92 }).toBuffer();
  const base64 = baseBuf.toString('base64');

  let headline = cleanHeadline(headlineHint) || (FALLBACK_HEADLINES[Math.floor(Math.random()*FALLBACK_HEADLINES.length)]).toUpperCase();
  let cta = cleanCTA(ctaHint) || FALLBACK_CTA[0];

  let h = 0; for (const c of String(seed || Date.now())) h = (h*31 + c.charCodeAt(0))>>>0;
  const tpl = (h % 4) + 1;

  const svg = renderImageSVG({ W, H, base64, headline, cta, tpl });

  const outDir = ensureGeneratedDir();
  const file = `${uuidv4()}.jpg`;
  fs.writeFileSync(path.join(outDir, file), await sharp(Buffer.from(svg)).jpeg({ quality: 95 }).toBuffer());
  return { publicUrl: `/generated/${file}`, absoluteUrl: absolutePublicUrl(`/generated/${file}`) };
}

// ---------- music ----------
function findMusicDir() {
  const candidates = [
    path.join(__dirname, '..', 'Music', 'music'),
    path.join(__dirname, '..', 'music', 'music'),
    path.join(__dirname, '..', 'Music'),
    path.join(__dirname, '..', 'music')
  ];
  for (const p of candidates) { try { if (fs.existsSync(p) && fs.statSync(p).isDirectory()) return p; } catch {} }
  return null;
}
function pickMusicFile(keywords = []) {
  const base = findMusicDir();
  if (!base) return null;
  const files = fs.readdirSync(base).filter(f => /\.mp3$/i.test(f));
  if (!files.length) return null;
  const lower = files.map(f => f.toLowerCase());
  for (const kw of keywords.map(x => String(x).toLowerCase())) {
    let i = lower.findIndex(f => f === `${kw}.mp3`); if (i !== -1) return path.join(base, files[i]);
    i = lower.findIndex(f => f.includes(kw)); if (i !== -1) return path.join(base, files[i]);
  }
  return path.join(base, files[0]);
}

// ---------- utils ----------
function withTimeout(p, ms, msg='Timeout') { return Promise.race([p, new Promise((_,rej)=>setTimeout(()=>rej(new Error(msg)), ms))]); }
async function downloadFileWithTimeout(url, dest, timeoutMs=30000, maxSizeMB=6) {
  return new Promise((resolve, reject) => {
    if (!url || !/^https?:\/\//i.test(String(url))) return reject(new Error('Invalid clip URL'));
    const writer = fs.createWriteStream(dest);
    let timedOut = false;
    const timeout = setTimeout(()=>{timedOut=true;writer.close();try{fs.unlinkSync(dest);}catch{};reject(new Error('Download timed out'));}, timeoutMs);
    axios({ url, method:'GET', responseType:'stream' })
      .then(resp => {
        let bytes=0;
        resp.data.on('data', ch => { bytes+=ch.length; if (bytes > maxSizeMB*1024*1024 && !timedOut) { timedOut=true; writer.close(); try{fs.unlinkSync(dest);}catch{}; clearTimeout(timeout); reject(new Error('File too large')); }});
        resp.data.pipe(writer);
        writer.on('finish', ()=>{clearTimeout(timeout); if (!timedOut) resolve(dest);});
        writer.on('error', err=>{clearTimeout(timeout); try{fs.unlinkSync(dest);}catch{}; if (!timedOut) reject(err);});
      })
      .catch(err=>{clearTimeout(timeout); try{fs.unlinkSync(dest);}catch{}; reject(err);});
  });
}
function getDeterministicShuffle(arr, seed) {
  const rng = seedrandom(String(seed || Date.now()));
  const a = [...arr];
  for (let i=a.length-1;i>0;i--){const j=Math.floor(rng()*(i+1));[a[i],a[j]]=[a[j],a[i]];}
  return a;
}
function safeFFText(t){
  return String(t||'')
    .replace(/[\n\r]/g,' ')
    .replace(/[:]/g,' ')
    .replace(/[\\'"]/g,'')
    .replace(/(?:https?:\/\/)?(?:www\.)?[a-z0-9\-]+\.[a-z]{2,}(?:\/\S*)?/gi,'')
    .replace(/\b(dot|com|net|org|io|co)\b/gi,'')
    .replace(/[^A-Za-z0-9 !?\-]/g,' ')
    .replace(/\s+/g,' ')
    .trim()
    .toUpperCase()
    .slice(0, 36);
}
function simpleCTA(input) {
  const t = String(input || '').toLowerCase();
  if (t.includes('buy')) return 'BUY NOW!';
  if (t.includes('shop')) return 'SHOP NOW!';
  if (t.includes('order')) return 'ORDER NOW!';
  if (t.includes('join')) return 'JOIN NOW!';
  if (t.includes('sign')) return 'SIGN UP!';
  if (t.includes('book')) return 'BOOK NOW!';
  if (t.includes('learn')) return 'LEARN MORE!';
  return 'SHOP NOW!';
}

// ---------- VIDEO (3 clips, 15–17s, curtains/bands fade after 1st clip, two variants) ----------
router.post('/generate-video-ad', async (req, res) => {
  res.setHeader('Content-Type', 'application/json');
  try {
    const { url = '', answers = {}, regenerateToken = '', variant = null } = req.body;

    const token = getUserToken(req);
    const fbAdAccountId =
      req.body.fbAdAccountId ||
      req.query.adAccountId ||
      req.headers['x-fb-ad-account-id'] ||
      null;

    // Square (vertical-friendly), modest resolution for speed
    const VIDEO = { W: 640, H: 640, FPS: 24 };
    const TO = { PEXELS: 20000, DL: 35000, FPROBE: 8000, OVERMUX: 120000 };

    const topic = deriveTopicKeywords(answers, url, 'shopping');
    const ctaText = simpleCTA(answers?.cta);

    // ----- fetch MANY, pick 3 short, small-width, >=7s duration -----
    let clips = [];
    try {
      const r = await withTimeout(
        axios.get('https://api.pexels.com/videos/search', {
          headers: { Authorization: PEXELS_API_KEY },
          params: { query: topic, per_page: 50, cb: Date.now() + (regenerateToken || '') }
        }),
        TO.PEXELS,
        'Pexels API timed out'
      );
      const videos = r.data?.videos || [];
      for (const v of videos) {
        if ((v.duration || 0) < 7) continue;
        const files = (v.video_files || [])
          .filter(f => f?.link && /\.mp4(\?|$)/i.test(f.link))
          .sort((a, b) => (a.width || 9999) - (b.width || 9999)); // smallest first
        if (files[0]?.link) {
          clips.push({ link: files[0].link, duration: v.duration || 8 });
        }
      }
    } catch (e) {
      console.error('Pexels fetch failed', e?.response?.data || e.message);
      return res.status(500).json({ error: 'Stock video fetch failed' });
    }
    if (clips.length < 3) return res.status(404).json({ error: 'Not enough stock clips found' });

    // deterministic but varied pick
    const shuffled = getDeterministicShuffle(clips, regenerateToken || answers?.businessName || topic || Date.now());
    const chosen = shuffled.slice(0, 3);

    // download 3 clips
    const tmp = path.join(__dirname, '../tmp');
    try { fs.mkdirSync(tmp, { recursive: true }); } catch {}
    const inputs = [];
    for (let i = 0; i < chosen.length; i++) {
      const out = path.join(tmp, `${uuidv4()}.mp4`);
      await withTimeout(downloadFileWithTimeout(chosen[i].link, out, TO.DL, 6), TO.DL + 1000, 'download timeout');
      inputs.push(out);
    }

    // ----- script (60–80 words) -----
    let prompt =
      `Write a simple, clear spoken ad script (~60–80 words). Do NOT mention a website. ` +
      `End with this exact CTA: '${ctaText}'. Topic: ${topic}` +
      (answers?.industry ? `\nCategory: ${answers.industry}` : '') +
      (answers?.businessName ? `\nBrand: ${answers.businessName}` : '') +
      (url ? `\nWebsite (context only): ${url}` : '');
    let script = 'Discover what you love today. Shop now!';
    try {
      const r = await withTimeout(
        openai.chat.completions.create({
          model: 'gpt-4o',
          messages: [{ role: 'user', content: prompt }],
          max_tokens: 180,
          temperature: 0.35
        }),
        14000,
        'OpenAI timeout'
      );
      script = (r.choices?.[0]?.message?.content?.trim() || script)
        .replace(/\s+/g, ' ')
        .replace(/(?:https?:\/\/)?(?:www\.)?[a-z0-9\-]+\.[a-z]{2,}(?:\/\S*)?/gi, '')
        .replace(/\b(dot|com|net|org|io|co)\b/gi, '')
        .trim();
    } catch {}

    // ----- TTS -----
    const ttsPath = path.join(tmp, `${uuidv4()}.mp3`);
    try {
      const ttsRes = await withTimeout(
        openai.audio.speech.create({ model: 'tts-1', voice: 'alloy', input: script }),
        18000,
        'TTS timeout'
      );
      fs.writeFileSync(ttsPath, Buffer.from(await ttsRes.arrayBuffer()));
    } catch (e) {
      console.error('TTS failed', e);
      return res.status(500).json({ error: 'TTS generation failed' });
    }

    // ----- VO duration and final duration (15–17s) -----
    async function probeDur(file) {
      try {
        const { stdout } = await withTimeout(
          exec(`ffprobe -v error -show_entries format=duration -of default=nokey=1:noprint_wrappers=1 "${file}"`),
          TO.FPROBE,
          'ffprobe timeout'
        );
        const s = parseFloat(stdout.trim());
        return isNaN(s) ? 0 : s;
      } catch { return 0; }
    }
    let voDur = await probeDur(ttsPath);
    if (voDur <= 0) voDur = 15.0;
    const finalDur = Math.max(15.0, Math.min(voDur, 17.0));

    // Split across 3 clips (first slightly longer so bands/curtains can fade off)
    const seg1 = Math.min(6.0, finalDur * 0.4);
    const seg2 = Math.max(4.2, (finalDur - seg1) / 2);
    const seg3 = Math.max(4.2, finalDur - seg1 - seg2);
    const segs = [seg1, seg2, seg3];
    const segEnd1 = seg1;
    const segEnd2 = seg1 + seg2;

    // ----- overlays (two variants) -----
    const serifFont = '/usr/share/fonts/truetype/dejavu/DejaVuSerif-Bold.ttf';
    const sansFont  = '/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf';
    const chosenFont = fs.existsSync(serifFont) ? serifFont : (fs.existsSync(sansFont) ? sansFont : null);
    const fontParam = chosenFont ? `fontfile='${chosenFont}':` : '';

    const brandLine = safeFFText(answers?.businessName || topic || 'JUST DROPPED');
    const ctaTxt    = safeFFText(ctaText);

    let styleVariant = Number(variant);
    if (![1,2].includes(styleVariant)) {
      let h = 0; for (const c of String(regenerateToken || answers?.businessName || Date.now())) h = (h * 31 + c.charCodeAt(0)) >>> 0;
      styleVariant = (h % 2) + 1;
    }

    // Intro/outro timings over the concatenated timeline
    const introStart = 0.25;
    const introEnd   = Math.min(seg1 - 0.2, 3.2);
    const outroStart = Math.max(0.0, finalDur - 2.4);
    const outroEnd   = finalDur;

    // Bars that fade away after first segment
    const TOP_H   = Math.round(VIDEO.H * 0.13);
    const BOT_H   = Math.round(VIDEO.H * 0.18);
    const CUR_W   = Math.round(VIDEO.W * 0.12);
    const fadeDur = 0.6;

    // Text chains (always boxed, with border & shadow for readability)
    const txtCommon = `fontcolor=white@0.99:borderw=2:bordercolor=black@0.88:shadowx=1:shadowy=1:shadowcolor=black@0.75`;
    const introY   = styleVariant === 1 ? (VIDEO.H - BOT_H + Math.round(BOT_H*0.36)) : Math.round(TOP_H*0.32);
    const introBox = styleVariant === 1
      ? `color=c=black@0.50:s=${VIDEO.W}x${BOT_H}:d=${finalDur.toFixed(2)},format=rgba,fade=t=out:st=${(seg1 - fadeDur).toFixed(2)}:d=${fadeDur}:alpha=1[bot]`
      : `color=c=black@0.50:s=${VIDEO.W}x${TOP_H}:d=${finalDur.toFixed(2)},format=rgba,fade=t=out:st=${(seg1 - fadeDur).toFixed(2)}:d=${fadeDur}:alpha=1[top]`;

    let textChain;
    if (styleVariant === 1) {
      const introT1 = `drawtext=${fontParam}text='${brandLine}':${txtCommon}:fontsize=32:x=40:y=${introY}:enable='between(t,${(introStart+0.10).toFixed(2)},${introEnd.toFixed(2)})'`;
      const introT2 = `drawtext=${fontParam}text='${ctaTxt}':${txtCommon}:box=1:boxcolor=0x0b0d10@0.80:boxborderw=18:fontsize=26:x=w-tw-40:y=${introY}:enable='between(t,${(introStart+0.45).toFixed(2)},${introEnd.toFixed(2)})'`;
      const outroT1 = `drawtext=${fontParam}text='${ctaTxt}':${txtCommon}:box=1:boxcolor=0x0b0d10@0.78:boxborderw=22:fontsize=44:x=(w-tw)/2:y=(h/2-16):enable='between(t,${outroStart.toFixed(2)},${outroEnd.toFixed(2)})'`;
      textChain = [introT1, introT2, outroT1].join(',');
    } else {
      const introT1 = `drawtext=${fontParam}text='${brandLine}':${txtCommon}:fontsize=28:x=40:y=${introY}:enable='between(t,${(introStart+0.10).toFixed(2)},${introEnd.toFixed(2)})'`;
      const introT2 = `drawtext=${fontParam}text='${ctaTxt}':${txtCommon}:box=1:boxcolor=0x0b0d10@0.80:boxborderw=16:fontsize=24:x=w-tw-40:y=${introY}:enable='between(t,${(introStart+0.40).toFixed(2)},${introEnd.toFixed(2)})'`;
      const outroT1 = `drawtext=${fontParam}text='${ctaTxt}':${txtCommon}:box=1:boxcolor=0x0b0d10@0.80:boxborderw=20:fontsize=44:x=(w-tw)/2:y=(h/2-16):enable='between(t,${outroStart.toFixed(2)},${outroEnd.toFixed(2)})'`;
      textChain = [introT1, introT2, outroT1].join(',');
    }

    // Optional BG music (very low)
    let bgMusicPath = null;
    try {
      const keys = [];
      if (answers?.industry) keys.push(answers.industry);
      if (answers?.businessName) keys.push(answers.businessName);
      bgMusicPath = pickMusicFile(keys);
    } catch {}
    const musicInput = bgMusicPath ? ` -i "${bgMusicPath}"` : '';

    // --- Build filter_complex ---
    // Per-input segment processing (compose to square with blur, then trim to segment length)
    const look = `format=yuv420p,fps=${VIDEO.FPS}`;
    const vidParts = [];
    for (let i = 0; i < inputs.length; i++) {
      const dur = segs[i];
      vidParts.push(
        `[${i}:v]split=2[v${i}a][v${i}b];` +
        `[v${i}a]scale=${VIDEO.W}:${VIDEO.H}:force_original_aspect_ratio=increase,` +
          `boxblur=luma_radius=18:luma_power=1:chroma_radius=18:chroma_power=1,` +
          `crop=${VIDEO.W}:${VIDEO.H}[bg${i}];` +
        `[v${i}b]scale='if(gte(iw/ih,1),${VIDEO.W},-2)':'if(gte(iw/ih,1),-2,${VIDEO.H})',setsar=1[fit${i}];` +
        `[bg${i}][fit${i}]overlay=x=(main_w-overlay_w)/2:y=(main_h-overlay_h)/2,${look},` +
        `trim=0:${dur.toFixed(2)},setpts=PTS-STARTPTS[s${i}]`
      );
    }
    const concat = `[s0][s1][s2]concat=n=3:v=1:a=0[vseq]`;

    // Curtains (fade out after first segment)
    const curtainFadeStart = Math.max(0.2, seg1 - 0.55).toFixed(2);
    const curtain = [
      `color=c=black@0.85:s=${CUR_W}x${VIDEO.H}:d=${finalDur.toFixed(2)},format=rgba,fade=t=out:st=${curtainFadeStart}:d=0.55:alpha=1[left]`,
      `color=c=black@0.85:s=${CUR_W}x${VIDEO.H}:d=${finalDur.toFixed(2)},format=rgba,fade=t=out:st=${curtainFadeStart}:d=0.55:alpha=1[right]`,
      `[vseq][left]overlay=shortest=1:x=0:y=0[b1]`,
      `[b1][right]overlay=shortest=1:x=main_w-overlay_w:y=0[b2]`
    ].join(';');

    // Top/Bottom band (variant-dependent), also fade out after seg1
    const bands = styleVariant === 1
      ? `;${introBox};[b2][bot]overlay=shortest=1:x=0:y=main_h-overlay_h[b3]`
      : `;${introBox};[b2][top]overlay=shortest=1:x=0:y=0[b3]`;

    // Text last (always boxed)
    const text = `;[b3]${textChain}[v]`;

    let filterComplex = vidParts.join(';') + ';' + concat + ';' + curtain + bands + text;

    // Audio mix (voice + low bg if present)
    let mapArgs;
    if (bgMusicPath) {
      filterComplex += `;[3:a]aresample=44100,volume=0.18,atrim=0:${finalDur.toFixed(2)},apad=pad_dur=${finalDur.toFixed(2)}[bg];` +
                       `[2:a]aresample=44100,pan=stereo|c0=c0|c1=c0,atrim=0:${finalDur.toFixed(2)},apad=pad_dur=${finalDur.toFixed(2)}[voice];` +
                       `[voice][bg]amix=inputs=2:duration=first:normalize=1[mix]`;
      mapArgs = `-map "[v]" -map "[mix]"`;
    } else {
      filterComplex += `;[2:a]aresample=44100,pan=stereo|c0=c0|c1=c0,atrim=0:${finalDur.toFixed(2)},apad=pad_dur=${finalDur.toFixed(2)}[mix]`;
      mapArgs = `-map "[v]" -map "[mix]"`;
    }

    const outDir = ensureGeneratedDir();
    const id = uuidv4();
    const outPath = path.join(outDir, `${id}.mp4`);

    // Build ffmpeg command with inputs: 3 videos + tts (+ music optional)
    const inputArgs = inputs.map(f => `-i "${f}"`).join(' ') + ` -i "${ttsPath}"` + (bgMusicPath ? ` -i "${bgMusicPath}"` : '');

    await withTimeout(
      exec(
        `ffmpeg -y ${inputArgs} ` +
        `-filter_complex "${filterComplex}" ${mapArgs} ` +
        `-t ${finalDur.toFixed(2)} ` +
        `-c:v libx264 -preset ultrafast -crf 28 -r ${VIDEO.FPS} -pix_fmt yuv420p ` +
        `-c:a aac -b:a 128k -ar 44100 -movflags +faststart -shortest "${outPath}"`
      ),
      TO.OVERMUX,
      'overlay+mux timeout'
    );

    // cleanup
    for (const f of inputs) { try { fs.unlinkSync(f); } catch {} }
    try { fs.unlinkSync(ttsPath); } catch {}

    const publicVideoUrl = `/generated/${id}.mp4`;
    const absoluteUrl = absolutePublicUrl(publicVideoUrl);

    // optional FB upload
    let fbVideoId = null;
    try {
      if (fbAdAccountId && token) {
        const up = await uploadVideoToAdAccount(
          fbAdAccountId, token, absoluteUrl,
          'SmartMark Generated Video', 'Generated by SmartMark'
        );
        fbVideoId = up?.id || null;
      }
    } catch (e) {
      console.error('FB upload fail:', e?.response?.data || e.message);
    }

    return res.json({
      videoUrl: publicVideoUrl,
      absoluteVideoUrl: absoluteUrl,
      fbVideoId,
      variant: styleVariant,
      script,
      ctaText,
      voice: 'alloy',
      video: { url: publicVideoUrl, script, overlayText: ctaText, voice: 'alloy', variant: styleVariant }
    });
  } catch (err) {
    console.error('video route error:', err);
    if (!res.headersSent)
      return res.status(500).json({ error: 'Failed to generate video ad', detail: err?.message || 'Unknown error' });
  }
});


// ---------- IMAGE: fetch + overlay ----------
router.post('/generate-image-from-prompt', async (req, res) => {
  try {
    // accept either top-level fields or {answers}
    const { regenerateToken = '' } = req.body;
    const top = req.body || {};
    const answers = top.answers || top;
    const url = answers.url || top.url || '';
    const industry = answers.industry || top.industry || '';

    const keyword = getImageKeyword(industry, url);

    let photos = [];
    try {
      const r = await axios.get(PEXELS_IMG_BASE, {
        headers: { Authorization: PEXELS_API_KEY },
        params: { query: keyword, per_page: 100, cb: Date.now() + (regenerateToken || '') },
        timeout: 4800
      });
      photos = r.data.photos || [];
    } catch (e) {
      console.error('Pexels img fetch error:', e?.message || e);
      return res.status(500).json({ error: 'Image search failed' });
    }
    if (!photos.length) return res.status(404).json({ error: 'No images found.' });

    const seed = regenerateToken || answers?.businessName || keyword || Date.now();
    let idxHash = 0; for (const c of String(seed)) idxHash = (idxHash*31 + c.charCodeAt(0))>>>0;
    const idx = (idxHash % photos.length);

    const img = photos[idx];
    const baseUrl = img.src.large2x || img.src.original || img.src.large;

    const headlineHint = answers?.businessName ? `${answers.businessName}` : (industry ? 'New Arrivals' : 'Great Picks');
    const ctaHint = answers?.cta || 'Shop Now!';

    let finalUrl = baseUrl;
    try {
      const { publicUrl } = await buildOverlayImage({ imageUrl: baseUrl, headlineHint, ctaHint, seed });
      finalUrl = publicUrl;
    } catch (e) {
      console.warn('Overlay build fail; using base image:', e.message);
    }

    res.json({ imageUrl: finalUrl, photographer: img.photographer, pexelsUrl: img.url, keyword, totalResults: photos.length, usedIndex: idx });
  } catch (e) {
    console.error('image route fail:', e?.message || e);
    res.status(500).json({ error: 'Failed to fetch stock image', detail: e.message });
  }
});

module.exports = router;
