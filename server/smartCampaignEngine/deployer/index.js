// server/smartCampaignEngine/deployer/index.js
// Creates adcreatives/ads inside the SAME ad set(s). Pauses losers. No budget changes.

const axios = require('axios');

async function fbPost(endpoint, body, params) {
  const url = `https://graph.facebook.com/v23.0/${endpoint}`;
  const res = await axios.post(url, body, { params });
  return res.data;
}
async function fbGet(endpoint, params) {
  const url = `https://graph.facebook.com/v23.0/${endpoint}`;
  const res = await axios.get(url, { params });
  return res.data;
}

async function uploadImageToAccount({ accountId, userToken, dataUrl }) {
  const m = /^data:(image\/\w+);base64,(.+)$/.exec(dataUrl || '');
  if (!m) throw new Error('Invalid image data URL');
  const base64 = m[2];
  const resp = await fbPost(`act_${accountId}/adimages`, new URLSearchParams({ bytes: base64 }), {
    access_token: userToken
  });
  const hash = Object.values(resp.images || {})[0]?.hash;
  if (!hash) throw new Error('Image upload failed');
  return hash;
}

async function ensureVideoId({ accountId, userToken, creativeVideo }) {
  if (creativeVideo.fbVideoId) return creativeVideo.fbVideoId;

  // If only absolute URL is present, upload to ad account library
  if (creativeVideo.absoluteUrl) {
    const form = new (require('form-data'))();
    // Facebook also accepts file_url directly (simpler & faster for your generated static file)
    form.append('file_url', creativeVideo.absoluteUrl);
    form.append('name', 'SmartMark Generated Video');
    form.append('description', 'Generated by SmartMark');

    const res = await axios.post(
      `https://graph.facebook.com/v23.0/act_${accountId}/advideos`,
      form,
      { headers: form.getHeaders(), params: { access_token: userToken } }
    );
    return res.data?.id;
  }
  throw new Error('No video available to upload');
}

async function createImageAd({ pageId, accountId, adsetId, adCopy, imageHash, userToken, link }) {
  const creative = await fbPost(`act_${accountId}/adcreatives`, {
    name: `SmartMark Image ${new Date().toISOString()}`,
    object_story_spec: {
      page_id: pageId,
      link_data: {
        message: adCopy,
        link: link || 'https://your-smartmark-site.com',
        image_hash: imageHash
      }
    }
  }, { access_token: userToken });

  const ad = await fbPost(`act_${accountId}/ads`, {
    name: `SmartMark Image Ad ${new Date().toISOString()}`,
    adset_id: adsetId,
    creative: { creative_id: creative.id },
    status: 'ACTIVE'
  }, { access_token: userToken });

  return ad.id;
}

async function createVideoAd({ pageId, accountId, adsetId, adCopy, videoId, imageHash, userToken, link }) {
  // Optional: fetch thumbnail
  let image_url = null;
  try {
    const thumbs = await fbGet(`${videoId}/thumbnails`, { access_token: userToken, fields: 'uri,is_preferred' });
    image_url = (thumbs.data || [])[0]?.uri || null;
  } catch {}

  const video_data = {
    video_id: videoId,
    message: adCopy,
    title: 'SmartMark Video',
    call_to_action: { type: 'LEARN_MORE', value: { link: link || 'https://your-smartmark-site.com' } }
  };
  if (image_url) video_data.image_url = image_url;

  const creative = await fbPost(`act_${accountId}/adcreatives`, {
    name: `SmartMark Video ${new Date().toISOString()}`,
    object_story_spec: { page_id: pageId, video_data }
  }, { access_token: userToken });

  const ad = await fbPost(`act_${accountId}/ads`, {
    name: `SmartMark Video Ad ${new Date().toISOString()}`,
    adset_id: adsetId,
    creative: { creative_id: creative.id },
    status: 'ACTIVE'
  }, { access_token: userToken });

  return ad.id;
}

async function pauseAds({ adIds, userToken }) {
  for (const id of adIds) {
    try {
      await fbPost(id, { status: 'PAUSED' }, { access_token: userToken });
    } catch (e) {
      // log and keep going
      console.warn('Pause failed for', id, e?.response?.data?.error?.message || e.message);
    }
  }
}

module.exports = {
  /**
   * Deploy 2 new creatives to each adset and pause losers.
   * @returns {Object} { createdAdsByAdset, pausedAdsByAdset }
   */
  async deploy({ accountId, pageId, campaignLink, adsetIds, winnersByAdset, losersByAdset, creatives, userToken }) {
    const createdAdsByAdset = {};
    const pausedAdsByAdset = {};

    for (const adsetId of adsetIds) {
      createdAdsByAdset[adsetId] = [];
      pausedAdsByAdset[adsetId] = [];

      // Build up to 2 ads: one image + one video (if available)
      const subset = creatives.slice(0, 2);

      for (const c of subset) {
        try {
          if (c.kind === 'image') {
            // fetch the image as base64 via your own file server
            const imgRes = await axios.get(c.imageUrl, { responseType: 'arraybuffer' });
            const dataUrl = `data:image/jpeg;base64,${Buffer.from(imgRes.data).toString('base64')}`;
            const hash = await uploadImageToAccount({ accountId, userToken, dataUrl });

            const adId = await createImageAd({
              pageId, accountId, adsetId,
              adCopy: c.adCopy,
              imageHash: hash,
              userToken,
              link: campaignLink
            });
            createdAdsByAdset[adsetId].push(adId);
          } else if (c.kind === 'video' && c.video) {
            const videoId = await ensureVideoId({ accountId, userToken, creativeVideo: c.video });
            const adId = await createVideoAd({
              pageId, accountId, adsetId,
              adCopy: c.adCopy,
              videoId,
              imageHash: null,
              userToken,
              link: campaignLink
            });
            createdAdsByAdset[adsetId].push(adId);
          }
        } catch (e) {
          console.warn('Create ad failed:', e?.response?.data?.error?.message || e.message);
        }
      }

      // Pause only the worst 1 per adset (as provided)
      const losers = losersByAdset[adsetId] || [];
      if (losers.length) {
        await pauseAds({ adIds: losers, userToken });
        pausedAdsByAdset[adsetId].push(...losers);
      }
    }

    return { createdAdsByAdset, pausedAdsByAdset };
  }
};
